name: Deploy Microservices

on:
  push:
    branches: [ main ]
    paths:
      - 'backend/lambda/**'
      - 'backend/base-images/**'
      - '.github/workflows/deploy.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'backend/lambda/**'
      - 'backend/base-images/**'
      - '.github/workflows/deploy.yml'
  workflow_dispatch:

env:
  AWS_REGION: ap-south-1
  ECR_REGISTRY: 090163643302.dkr.ecr.ap-south-1.amazonaws.com

jobs:
  detect-base-image-changes:
    runs-on: ubuntu-latest
    outputs:
      build-docling: ${{ steps.changes.outputs.build_docling }}
      build-sentence-transformers: ${{ steps.changes.outputs.build_sentence_transformers }}
      build-any: ${{ steps.changes.outputs.build_any }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Detect base image changes
      id: changes
      run: |
        # Get list of changed files
        if [ "${{ github.event_name }}" = "push" ]; then
          CHANGED_FILES=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }})
        else
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
        fi
        
        echo "Changed files:"
        echo "$CHANGED_FILES"
        
        # Check for changes in base image files
        BUILD_DOCLING="false"
        BUILD_DOCLING_OCR="false"
        BUILD_DOCLING_CORE="false"
        BUILD_DOCLING_TABLES="false"
        BUILD_SENTENCE_TRANSFORMERS="false"
        BUILD_EMBEDDINGS_LIGHT="false"
        BUILD_ANY="false"
        
        if echo "$CHANGED_FILES" | grep -q "backend/base-images/Dockerfile.docling$"; then
          BUILD_DOCLING="true"
          BUILD_ANY="true"
          echo "âœ… Docling base image needs rebuild"
        else
          echo "â­ï¸ Docling base image - no changes"
        fi
        
        if echo "$CHANGED_FILES" | grep -q "backend/base-images/Dockerfile.docling-ocr"; then
          BUILD_DOCLING_OCR="true"
          BUILD_ANY="true"
          echo "âœ… Docling OCR base image needs rebuild"
        else
          echo "â­ï¸ Docling OCR base image - no changes"
        fi
        
        if echo "$CHANGED_FILES" | grep -q "backend/base-images/Dockerfile.docling-core"; then
          BUILD_DOCLING_CORE="true"
          BUILD_ANY="true"
          echo "âœ… Docling Core base image needs rebuild"
        else
          echo "â­ï¸ Docling Core base image - no changes"
        fi
        
        if echo "$CHANGED_FILES" | grep -q "backend/base-images/Dockerfile.docling-tables"; then
          BUILD_DOCLING_TABLES="true"
          BUILD_ANY="true"
          echo "âœ… Docling Tables base image needs rebuild"
        else
          echo "â­ï¸ Docling Tables base image - no changes"
        fi
        
        if echo "$CHANGED_FILES" | grep -q "backend/base-images/Dockerfile.sentence-transformers"; then
          BUILD_SENTENCE_TRANSFORMERS="true"
          BUILD_ANY="true"
          echo "âœ… Sentence-transformers base image needs rebuild"
        else
          echo "â­ï¸ Sentence-transformers base image - no changes"
        fi
        
        if echo "$CHANGED_FILES" | grep -q "backend/base-images/Dockerfile.embeddings-light"; then
          BUILD_EMBEDDINGS_LIGHT="true"
          BUILD_ANY="true"
          echo "âœ… Embeddings Light base image needs rebuild"
        else
          echo "â­ï¸ Embeddings Light base image - no changes"
        fi
        
        # If any base image files changed, set build_any to true
        if echo "$CHANGED_FILES" | grep -q "backend/base-images/"; then
          BUILD_ANY="true"
        fi
        
        echo "build_docling=$BUILD_DOCLING" >> $GITHUB_OUTPUT
        echo "build_docling_ocr=$BUILD_DOCLING_OCR" >> $GITHUB_OUTPUT
        echo "build_docling_core=$BUILD_DOCLING_CORE" >> $GITHUB_OUTPUT
        echo "build_docling_tables=$BUILD_DOCLING_TABLES" >> $GITHUB_OUTPUT
        echo "build_sentence_transformers=$BUILD_SENTENCE_TRANSFORMERS" >> $GITHUB_OUTPUT
        echo "build_embeddings_light=$BUILD_EMBEDDINGS_LIGHT" >> $GITHUB_OUTPUT
        echo "build_any=$BUILD_ANY" >> $GITHUB_OUTPUT

  build-base-images:
    needs: detect-base-image-changes
    if: always()
    runs-on: ubuntu-latest
    environment: chatbot
    timeout-minutes: 60
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download Build State
      uses: actions/download-artifact@v4
      with:
        name: build-state
        path: ./
      continue-on-error: true

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Setup Docker
      run: |
        echo "ðŸ³ Setting up Docker for builds..."
        
        # Set Docker build settings
        export DOCKER_BUILDKIT=1
        export BUILDKIT_PROGRESS=plain

    - name: Check Build State
      run: |
        echo "ðŸ” Checking build state for resumption..."
        
        # Create build state file
        BUILD_STATE_FILE="build_state.json"
        
        # Initialize build state if it doesn't exist
        if [ ! -f "$BUILD_STATE_FILE" ]; then
          cat > "$BUILD_STATE_FILE" << EOF
        {
          "completed_images": [],
          "failed_images": [],
          "build_start_time": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
        }
        EOF
        fi
        
        # Load existing state
        COMPLETED_IMAGES=$(jq -r '.completed_images[]' "$BUILD_STATE_FILE" 2>/dev/null || echo "")
        FAILED_IMAGES=$(jq -r '.failed_images[]' "$BUILD_STATE_FILE" 2>/dev/null || echo "")
        
        echo "âœ… Previously completed images: $COMPLETED_IMAGES"
        echo "âŒ Previously failed images: $FAILED_IMAGES"
        
        # Save state for other steps
        echo "COMPLETED_IMAGES=$COMPLETED_IMAGES" >> $GITHUB_ENV
        echo "FAILED_IMAGES=$FAILED_IMAGES" >> $GITHUB_ENV

    - name: Build and push base images
      run: |
        echo "ðŸ—ï¸ Building and pushing base images with resume capability..."
        
        # Create ECR repositories for base images
        for base_image in docling docling-ocr docling-core docling-tables sentence-transformers embeddings-light; do
          echo "ðŸ“‹ Ensuring ECR repository exists for chatbot-base-$base_image..."
          if aws ecr describe-repositories --repository-names "chatbot-base-$base_image" --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
            echo "Repository chatbot-base-$base_image already exists"
          else
            echo "Creating repository chatbot-base-$base_image..."
            aws ecr create-repository --repository-name "chatbot-base-$base_image" --region ${{ env.AWS_REGION }}
            
            # Set ECR repository policy
            aws ecr set-repository-policy \
              --repository-name "chatbot-base-$base_image" \
              --region ${{ env.AWS_REGION }} \
              --policy-text '{
                  "Version": "2012-10-17",
                  "Statement": [
                      {
                          "Sid": "LambdaECRImageRetrievalPolicy",
                          "Effect": "Allow",
                          "Principal": {
                              "Service": "lambda.amazonaws.com"
                          },
                          "Action": [
                              "ecr:BatchGetImage",
                              "ecr:GetDownloadUrlForLayer"
                          ]
                      }
                  ]
              }' || echo "Policy already set"
          fi
        done
        
        # Build and push base images
        cd backend/base-images
        
        # Build specialized base images - always build if they don't exist or if there are changes
        BUILD_DOCLING="${{ needs.detect-base-image-changes.outputs.build_docling }}"
        BUILD_DOCLING_OCR="${{ needs.detect-base-image-changes.outputs.build_docling_ocr }}"
        BUILD_DOCLING_CORE="${{ needs.detect-base-image-changes.outputs.build_docling_core }}"
        BUILD_DOCLING_TABLES="${{ needs.detect-base-image-changes.outputs.build_docling_tables }}"
        BUILD_SENTENCE_TRANSFORMERS="${{ needs.detect-base-image-changes.outputs.build_sentence_transformers }}"
        BUILD_EMBEDDINGS_LIGHT="${{ needs.detect-base-image-changes.outputs.build_embeddings_light }}"
        
        # Check if base images exist in ECR
        if ! aws ecr describe-images --repository-name chatbot-base-docling --image-ids imageTag=latest --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
          echo "ðŸ“¦ Docling base image doesn't exist, building it..."
          BUILD_DOCLING="true"
        fi
        
        if ! aws ecr describe-images --repository-name chatbot-base-docling-ocr --image-ids imageTag=latest --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
          echo "ðŸ“¦ Docling OCR base image doesn't exist, building it..."
          BUILD_DOCLING_OCR="true"
        fi
        
        if ! aws ecr describe-images --repository-name chatbot-base-docling-core --image-ids imageTag=latest --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
          echo "ðŸ“¦ Docling Core base image doesn't exist, building it..."
          BUILD_DOCLING_CORE="true"
        fi
        
        if ! aws ecr describe-images --repository-name chatbot-base-docling-tables --image-ids imageTag=latest --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
          echo "ðŸ“¦ Docling Tables base image doesn't exist, building it..."
          BUILD_DOCLING_TABLES="true"
        fi
        
        if ! aws ecr describe-images --repository-name chatbot-base-sentence-transformers --image-ids imageTag=latest --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
          echo "ðŸ“¦ Sentence-transformers base image doesn't exist, building it..."
          BUILD_SENTENCE_TRANSFORMERS="true"
        fi
        
        if ! aws ecr describe-images --repository-name chatbot-base-embeddings-light --image-ids imageTag=latest --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
          echo "ðŸ“¦ Embeddings Light base image doesn't exist, building it..."
          BUILD_EMBEDDINGS_LIGHT="true"
        fi
        
        # Function to build image with memory management and resume capability
        build_image() {
          local image_name=$1
          local dockerfile=$2
          local ecr_repo=$3
          
          # Check if this image was already completed
          if echo "$COMPLETED_IMAGES" | grep -q "$image_name"; then
            echo "â­ï¸ $image_name already completed, skipping..."
            return 0
          fi
          
          # Check if this image previously failed
          if echo "$FAILED_IMAGES" | grep -q "$image_name"; then
            echo "ðŸ”„ Retrying previously failed image: $image_name"
          else
            echo "ðŸ”¨ Building $image_name..."
          fi
          
          # Simple build - let it fail naturally if out of memory
          if docker build -f "$dockerfile" -t "$image_name:latest" .; then
            echo "âœ… Build successful for $image_name"
          else
            echo "âŒ Build failed for $image_name"
            # Mark as failed in state file
            echo "ðŸ“ Marking $image_name as failed..."
            jq --arg img "$image_name" '.failed_images += [$img] | .completed_images -= [$img]' "$BUILD_STATE_FILE" > "${BUILD_STATE_FILE}.tmp" && mv "${BUILD_STATE_FILE}.tmp" "$BUILD_STATE_FILE"
            return 1
          fi
          
          # Tag and push
          docker tag "$image_name:latest" "${{ env.ECR_REGISTRY }}/$ecr_repo:latest"
          docker push "${{ env.ECR_REGISTRY }}/$ecr_repo:latest"
          
          # Clean up local images
          docker rmi "$image_name:latest" "${{ env.ECR_REGISTRY }}/$ecr_repo:latest" || true
          
          # Mark as completed in state file
          echo "ðŸ“ Marking $image_name as completed..."
          jq --arg img "$image_name" '.completed_images += [$img] | .failed_images -= [$img]' "$BUILD_STATE_FILE" > "${BUILD_STATE_FILE}.tmp" && mv "${BUILD_STATE_FILE}.tmp" "$BUILD_STATE_FILE"
          
          echo "âœ… $image_name built and pushed successfully!"
        }
        
        # Build docling base image if needed
        if [ "$BUILD_DOCLING" = "true" ]; then
          build_image "chatbot-base-docling" "Dockerfile.docling" "chatbot-base-docling"
        else
          echo "â­ï¸ Docling base image already exists, skipping build"
        fi
        
        # Build docling OCR base image if needed
        if [ "$BUILD_DOCLING_OCR" = "true" ]; then
          build_image "chatbot-base-docling-ocr" "Dockerfile.docling-ocr" "chatbot-base-docling-ocr"
        else
          echo "â­ï¸ Docling OCR base image already exists, skipping build"
        fi
        
        # Build docling core base image if needed
        if [ "$BUILD_DOCLING_CORE" = "true" ]; then
          build_image "chatbot-base-docling-core" "Dockerfile.docling-core" "chatbot-base-docling-core"
        else
          echo "â­ï¸ Docling Core base image already exists, skipping build"
        fi
        
        # Build docling tables base image if needed
        if [ "$BUILD_DOCLING_TABLES" = "true" ]; then
          build_image "chatbot-base-docling-tables" "Dockerfile.docling-tables" "chatbot-base-docling-tables"
        else
          echo "â­ï¸ Docling Tables base image already exists, skipping build"
        fi
        
        # Build sentence-transformers base image if needed
        if [ "$BUILD_SENTENCE_TRANSFORMERS" = "true" ]; then
          build_image "chatbot-base-sentence-transformers" "Dockerfile.sentence-transformers" "chatbot-base-sentence-transformers"
        else
          echo "â­ï¸ Sentence-transformers base image already exists, skipping build"
        fi
        
        # Build embeddings light base image if needed
        if [ "$BUILD_EMBEDDINGS_LIGHT" = "true" ]; then
          build_image "chatbot-base-embeddings-light" "Dockerfile.embeddings-light" "chatbot-base-embeddings-light"
        else
          echo "â­ï¸ Embeddings Light base image already exists, skipping build"
        fi
        
        echo "ðŸŽ‰ Base images build completed!"
        
        # Upload build state as artifact
        echo "ðŸ“¤ Uploading build state..."
        echo "Final build state:"
        BUILD_STATE_FILE="build_state.json"
        if [ -f "$BUILD_STATE_FILE" ]; then
          cat "$BUILD_STATE_FILE"
        else
          echo "No build state file found"
        fi
        
        # Create artifact directory
        mkdir -p artifacts
        if [ -f "$BUILD_STATE_FILE" ]; then
          cp "$BUILD_STATE_FILE" artifacts/
        else
          echo "No build state file to copy"
        fi
        
        # Upload as artifact
        echo "Uploading build state artifact..."

    - name: Upload Build State
      uses: actions/upload-artifact@v4
      with:
        name: build-state
        path: artifacts/build_state.json
        retention-days: 7

  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      services: ${{ steps.changes.outputs.services }}
    if: always()
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Detect changed services
      id: changes
      run: |
        # Get list of changed files
        if [ "${{ github.event_name }}" = "push" ]; then
          CHANGED_FILES=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }})
        else
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
        fi
        
        echo "Changed files:"
        echo "$CHANGED_FILES"
        
        # Check for changes in each service
        CHANGED_SERVICES=""
        
        for service in action-executor chat-handler claude-decision conversation-manager document-content document-management document-metadata embedding-service orchestrator presigned-url rag-processor rag-search response-enhancement response-formatter source-extractor vector-search; do
          if echo "$CHANGED_FILES" | grep -q "backend/lambda/$service/"; then
            CHANGED_SERVICES="$CHANGED_SERVICES $service"
            echo "âœ… $service has changes"
          else
            echo "â­ï¸ $service - no changes"
          fi
        done
        
        # If no specific services changed, but lambda files changed, build all
        if [ -z "$CHANGED_SERVICES" ] && echo "$CHANGED_FILES" | grep -q "backend/lambda/"; then
          echo "ðŸ”„ No specific service changes detected, building all services"
          CHANGED_SERVICES="action-executor chat-handler claude-decision conversation-manager document-content document-management document-metadata embedding-service orchestrator rag-processor rag-search response-enhancement response-formatter source-extractor vector-search"
        fi
        
        # If no lambda changes at all, don't build anything
        if [ -z "$CHANGED_SERVICES" ]; then
          echo "â­ï¸ No lambda changes detected, skipping build"
          echo "services=[]" >> $GITHUB_OUTPUT
        else
          echo "ðŸ“¦ Services to build: $CHANGED_SERVICES"
          # Convert to JSON array - more robust approach
          SERVICES_ARRAY=()
          for service in $CHANGED_SERVICES; do
            if [ -n "$service" ]; then
              SERVICES_ARRAY+=("\"$service\"")
            fi
          done
          SERVICES_JSON="[$(IFS=,; echo "${SERVICES_ARRAY[*]}")]"
          echo "services=$SERVICES_JSON" >> $GITHUB_OUTPUT
        fi

  build-and-deploy:
    needs: [detect-base-image-changes, build-base-images, detect-changes]
    if: always()
    runs-on: ubuntu-latest
    environment: chatbot
    timeout-minutes: 90
    strategy:
      max-parallel: 5
      matrix:
        service: ${{ fromJson(needs.detect-changes.outputs.services) }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Setup Memory Management for Lambda Build
      run: |
        echo "ðŸ§  Setting up memory management for Lambda build (${{ matrix.service }})..."
        
        # Configure Docker for better memory management
        echo '{"max-concurrent-downloads": 2, "max-concurrent-uploads": 2}' | sudo tee /etc/docker/daemon.json
        sudo systemctl restart docker || echo "Docker restart not available in GitHub Actions"
        
        # Set Docker build memory limits
        export DOCKER_BUILDKIT=1
        export BUILDKIT_PROGRESS=plain
        
        # Clean up any existing Docker resources
        echo "ðŸ§¹ Cleaning up Docker resources..."
        docker system prune -f || true
        docker builder prune -f || true
        
        # Show available memory
        echo "ðŸ“Š Available system resources:"
        free -h
        df -h
        docker system df

    - name: Create ECR repository
      run: |
        echo "Ensuring ECR repository exists for ${{ matrix.service }}..."
        if aws ecr describe-repositories --repository-names "chatbot-${{ matrix.service }}" --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
          echo "Repository chatbot-${{ matrix.service }} already exists"
        else
          echo "Creating repository chatbot-${{ matrix.service }}..."
          aws ecr create-repository --repository-name "chatbot-${{ matrix.service }}" --region ${{ env.AWS_REGION }}
        fi
        
        # Set ECR repository policy to allow Lambda access
        echo "Setting ECR repository policy for Lambda access..."
        aws ecr set-repository-policy \
          --repository-name "chatbot-${{ matrix.service }}" \
          --region ${{ env.AWS_REGION }} \
          --policy-text '{
            "Version": "2012-10-17",
            "Statement": [
              {
                "Sid": "LambdaECRImageRetrievalPolicy",
                "Effect": "Allow",
                "Principal": {
                  "Service": "lambda.amazonaws.com"
                },
                "Action": [
                  "ecr:BatchGetImage",
                  "ecr:GetDownloadUrlForLayer"
                ]
              }
            ]
          }' || echo "Policy already set or failed to set"

    - name: Build and push Docker image
      run: |
        echo "Building and pushing ${{ matrix.service }}..."
        
        # Verify shared directory exists
        if [ -d "backend/lambda/shared" ]; then
          echo "Shared directory found at backend/lambda/shared"
        else
          echo "Warning: Shared directory not found, but continuing with build"
        fi
        
        # Build Docker image with correct context (lambda directory)
        echo "Starting Docker build for ${{ matrix.service }}..."
        echo "Build context: backend/lambda"
        echo "Dockerfile: backend/lambda/${{ matrix.service }}/Dockerfile"
        
        # Build with memory management and retry logic
        echo "ðŸ”¨ Building Lambda function: ${{ matrix.service }}"
        
        # Monitor memory before build
        echo "ðŸ“Š Memory before build:"
        free -h
        
        # Build with retry logic
        local retry_count=0
        local max_retries=3
        
        while [ $retry_count -lt $max_retries ]; do
          if docker build --no-cache --memory=2g --memory-swap=3g -t chatbot-${{ matrix.service }} -f backend/lambda/${{ matrix.service }}/Dockerfile backend/lambda 2>&1 | tee lambda_build.log; then
            echo "âœ… Build successful for ${{ matrix.service }}"
            break
          else
            retry_count=$((retry_count + 1))
            echo "âŒ Build failed for ${{ matrix.service }} (attempt $retry_count/$max_retries)"
            
            # Check if it's a space/OOM error
            if grep -q "No space left on device\|out of memory\|OOM\|ENOSPC" lambda_build.log; then
              echo "ðŸš¨ Space/OOM error detected, performing aggressive cleanup..."
              
              # Aggressive cleanup for space/OOM issues
              docker system prune -af --volumes || true
              docker builder prune -af || true
              docker image prune -af || true
              docker container prune -f || true
              docker volume prune -f || true
              docker network prune -f || true
              
              # Clean up system caches
              sudo apt-get clean || true
              sudo rm -rf /var/lib/apt/lists/* || true
              sudo rm -rf /tmp/* || true
              sudo rm -rf /var/tmp/* || true
              rm -rf ~/.cache/pip || true
              rm -rf /tmp/pip-* || true
              
              # Clean up logs
              sudo find /var/log -name "*.log" -type f -delete || true
              sudo journalctl --vacuum-time=1d || true
              
              echo "ðŸ“Š Space after aggressive cleanup:"
              df -h
              docker system df
              
              sleep 20
            else
              echo "ðŸ§¹ Regular cleanup and retrying..."
              docker system prune -f || true
              docker builder prune -f || true
              sleep 15
            fi
            
            if [ $retry_count -ge $max_retries ]; then
              echo "ðŸ’¥ Build failed after $max_retries attempts"
              exit 1
            fi
          fi
        done
        
        # Clean up after build
        echo "ðŸ§¹ Cleaning up after build..."
        docker system prune -f || true
        
        # Tag for ECR
        echo "Tagging image for ECR..."
        docker tag chatbot-${{ matrix.service }}:latest ${{ env.ECR_REGISTRY }}/chatbot-${{ matrix.service }}:latest
        
        # Push to ECR with retry logic
        echo "Pushing image to ECR..."
        for i in {1..3}; do
          echo "Push attempt $i/3 for ${{ matrix.service }}..."
          if docker push ${{ env.ECR_REGISTRY }}/chatbot-${{ matrix.service }}:latest; then
            echo "Successfully pushed ${{ matrix.service }} on attempt $i"
            break
          else
            echo "Push attempt $i failed for ${{ matrix.service }}"
            if [ $i -eq 3 ]; then
              echo "All push attempts failed for ${{ matrix.service }}"
              exit 1
            fi
            echo "Waiting 10 seconds before retry..."
            sleep 10
          fi
        done
        
        # Clean up local image to save space
        echo "Cleaning up local image for ${{ matrix.service }}..."
        docker rmi chatbot-${{ matrix.service }}:latest ${{ env.ECR_REGISTRY }}/chatbot-${{ matrix.service }}:latest || true
        
        # Clean up Docker system resources
        echo "Cleaning up Docker system resources..."
        docker system prune -f || true
        
        echo "Successfully completed ${{ matrix.service }}"

    - name: Ensure IAM role exists
      run: |
        echo "Ensuring IAM role exists..."
        aws iam get-role --role-name chatbot-lambda-role || {
          echo "Creating IAM role chatbot-lambda-role..."
          aws iam create-role \
            --role-name chatbot-lambda-role \
            --assume-role-policy-document '{
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Principal": {
                    "Service": "lambda.amazonaws.com"
                  },
                  "Action": "sts:AssumeRole"
                }
              ]
            }'
          
          aws iam attach-role-policy \
            --role-name chatbot-lambda-role \
            --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
          
          aws iam attach-role-policy \
            --role-name chatbot-lambda-role \
            --policy-arn arn:aws:iam::aws:policy/AmazonS3FullAccess
          
          aws iam attach-role-policy \
            --role-name chatbot-lambda-role \
            --policy-arn arn:aws:iam::aws:policy/AmazonDynamoDBFullAccess
          
          # Add ECR permissions
          aws iam attach-role-policy \
            --role-name chatbot-lambda-role \
            --policy-arn arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly
          
          echo "IAM role created successfully"
        }

    - name: Deploy Lambda function
      run: |
        echo "Deploying Lambda function for ${{ matrix.service }}..."
        
        # Service configurations
        case "${{ matrix.service }}" in
          "rag-processor")
            memory=2048; timeout=900; env_vars="MAIN_BUCKET=chatbot-storage-ap-south-1,KNOWLEDGE_BASE_TABLE=chatbot-knowledge-base"
            ;;
          "chat-handler")
            memory=1024; timeout=300; env_vars="CLAUDE_API_KEY=${{ secrets.CLAUDE_API_KEY }},MAIN_BUCKET=chatbot-storage-ap-south-1,CONVERSATIONS_TABLE=chatbot-conversations,KNOWLEDGE_BASE_TABLE=chatbot-knowledge-base"
            ;;
          "orchestrator")
            memory=1024; timeout=300; env_vars="CLAUDE_API_KEY=${{ secrets.CLAUDE_API_KEY }},RAG_SEARCH_LAMBDA=chatbot-rag-search,DOCUMENT_MANAGEMENT_LAMBDA=chatbot-document-management,RESPONSE_ENHANCEMENT_LAMBDA=chatbot-response-enhancement,CONVERSATIONS_TABLE=chatbot-conversations"
            ;;
          "rag-search")
            memory=2048; timeout=300; env_vars="MAIN_BUCKET=chatbot-storage-ap-south-1,KNOWLEDGE_BASE_TABLE=chatbot-knowledge-base"
            ;;
          "document-management")
            memory=512; timeout=300; env_vars="MAIN_BUCKET=chatbot-storage-ap-south-1,KNOWLEDGE_BASE_TABLE=chatbot-knowledge-base"
            ;;
          "response-enhancement")
            memory=1024; timeout=300; env_vars="CLAUDE_API_KEY=${{ secrets.CLAUDE_API_KEY }},CONVERSATIONS_TABLE=chatbot-conversations"
            ;;
          "claude-decision")
            memory=1024; timeout=300; env_vars="CLAUDE_API_KEY=${{ secrets.CLAUDE_API_KEY }},CONVERSATIONS_TABLE=chatbot-conversations"
            ;;
          "action-executor")
            memory=512; timeout=300; env_vars="RAG_SEARCH_LAMBDA=chatbot-rag-search,DOCUMENT_METADATA_LAMBDA=chatbot-document-metadata,DOCUMENT_CONTENT_LAMBDA=chatbot-document-content,EMBEDDING_SERVICE_LAMBDA=chatbot-embedding-service,VECTOR_SEARCH_LAMBDA=chatbot-vector-search"
            ;;
          "embedding-service")
            memory=2048; timeout=300; env_vars="MAIN_BUCKET=chatbot-storage-ap-south-1"
            ;;
          "vector-search")
            memory=1024; timeout=300; env_vars="MAIN_BUCKET=chatbot-storage-ap-south-1,KNOWLEDGE_BASE_TABLE=chatbot-knowledge-base"
            ;;
          "document-metadata")
            memory=256; timeout=300; env_vars="MAIN_BUCKET=chatbot-storage-ap-south-1,KNOWLEDGE_BASE_TABLE=chatbot-knowledge-base"
            ;;
          "document-content")
            memory=256; timeout=300; env_vars="MAIN_BUCKET=chatbot-storage-ap-south-1"
            ;;
          "source-extractor")
            memory=256; timeout=300; env_vars=""
            ;;
          "response-formatter")
            memory=256; timeout=300; env_vars=""
            ;;
          "conversation-manager")
            memory=256; timeout=300; env_vars="CONVERSATIONS_TABLE=chatbot-conversations"
            ;;
          "presigned-url")
            memory=512; timeout=300; env_vars="MAIN_BUCKET=chatbot-storage-ap-south-1"
            ;;
        esac
        
        # Create or update Lambda function
        if aws lambda get-function --function-name "chatbot-${{ matrix.service }}" --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
          echo "Lambda function chatbot-${{ matrix.service }} already exists, updating code..."
          aws lambda update-function-code \
            --function-name "chatbot-${{ matrix.service }}" \
            --image-uri "${{ env.ECR_REGISTRY }}/chatbot-${{ matrix.service }}:latest" || {
              echo "Failed to update Lambda function ${{ matrix.service }}"
              exit 1
            }
          echo "Successfully updated Lambda function ${{ matrix.service }}"
        else
          echo "Creating Lambda function chatbot-${{ matrix.service }}..."
          aws lambda create-function \
            --function-name "chatbot-${{ matrix.service }}" \
            --package-type Image \
            --code ImageUri="${{ env.ECR_REGISTRY }}/chatbot-${{ matrix.service }}:latest" \
            --role "arn:aws:iam::090163643302:role/chatbot-lambda-role" \
            --timeout $timeout \
            --memory-size $memory \
            --environment Variables="{$env_vars}" \
            --tags Environment=production,Service=${{ matrix.service }} || {
              echo "Failed to create Lambda function ${{ matrix.service }}"
              exit 1
            }
          echo "Successfully created Lambda function ${{ matrix.service }}"
        fi

  create-api-gateway:
    needs: [detect-changes]
    runs-on: ubuntu-latest
    environment: chatbot
    if: always()
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Create or update API Gateway
      run: |
        echo "Setting up API Gateway..."
        
        # Check if API Gateway exists
        API_ID=$(aws apigateway get-rest-apis --query 'items[?name==`chatbot-microservices-api`].id' --output text)
        
        if [ -z "$API_ID" ] || [ "$API_ID" = "None" ]; then
          echo "Creating new API Gateway..."
          API_ID=$(aws apigateway create-rest-api \
            --name chatbot-microservices-api \
            --description "API Gateway for chatbot microservices" \
            --query 'id' --output text)
        else
          echo "Using existing API Gateway: $API_ID"
        fi
        
        echo "API_ID=$API_ID" >> $GITHUB_ENV
        
        # Get root resource ID
        ROOT_RESOURCE_ID=$(aws apigateway get-resources --rest-api-id $API_ID --query 'items[?path==`/`].id' --output text)
        
        # Create or get chat resource
        echo "Creating or getting chat resource..."
        CHAT_RESOURCE_ID=$(aws apigateway get-resources \
          --rest-api-id $API_ID \
          --query "items[?pathPart=='chat' && parentId=='$ROOT_RESOURCE_ID'].id" --output text)
        
        if [ -z "$CHAT_RESOURCE_ID" ] || [ "$CHAT_RESOURCE_ID" = "None" ]; then
          echo "Creating new chat resource..."
          CHAT_RESOURCE_ID=$(aws apigateway create-resource \
            --rest-api-id $API_ID \
            --parent-id $ROOT_RESOURCE_ID \
            --path-part chat \
            --query 'id' --output text)
        else
          echo "Using existing chat resource: $CHAT_RESOURCE_ID"
        fi
        
        # Create or get knowledge-base resource
        echo "Creating or getting knowledge-base resource..."
        KNOWLEDGE_BASE_RESOURCE_ID=$(aws apigateway get-resources \
          --rest-api-id $API_ID \
          --query "items[?pathPart=='knowledge-base' && parentId=='$ROOT_RESOURCE_ID'].id" --output text)
        
        if [ -z "$KNOWLEDGE_BASE_RESOURCE_ID" ] || [ "$KNOWLEDGE_BASE_RESOURCE_ID" = "None" ]; then
          echo "Creating new knowledge-base resource..."
          KNOWLEDGE_BASE_RESOURCE_ID=$(aws apigateway create-resource \
            --rest-api-id $API_ID \
            --parent-id $ROOT_RESOURCE_ID \
            --path-part knowledge-base \
            --query 'id' --output text)
        else
          echo "Using existing knowledge-base resource: $KNOWLEDGE_BASE_RESOURCE_ID"
        fi
        
        # Create or update POST method
        echo "Setting up POST method..."
        aws apigateway put-method \
          --rest-api-id $API_ID \
          --resource-id $CHAT_RESOURCE_ID \
          --http-method POST \
          --authorization-type NONE || echo "POST method may already exist"
        
        # Create or update OPTIONS method for CORS
        echo "Setting up OPTIONS method..."
        aws apigateway put-method \
          --rest-api-id $API_ID \
          --resource-id $CHAT_RESOURCE_ID \
          --http-method OPTIONS \
          --authorization-type NONE || echo "OPTIONS method may already exist"
        
        # Set up POST integration
        echo "Setting up POST integration..."
        aws apigateway put-integration \
          --rest-api-id $API_ID \
          --resource-id $CHAT_RESOURCE_ID \
          --http-method POST \
          --type AWS_PROXY \
          --integration-http-method POST \
          --uri "arn:aws:apigateway:${{ env.AWS_REGION }}:lambda:path/2015-03-31/functions/arn:aws:lambda:${{ env.AWS_REGION }}:090163643302:function:chatbot-orchestrator/invocations" || echo "POST integration may already exist"
        
        # Set up OPTIONS method response for CORS (must be before integration response)
        echo "Setting up OPTIONS method response..."
        aws apigateway put-method-response \
          --rest-api-id $API_ID \
          --resource-id $CHAT_RESOURCE_ID \
          --http-method OPTIONS \
          --status-code 200 \
          --response-parameters '{
            "method.response.header.Access-Control-Allow-Headers": true,
            "method.response.header.Access-Control-Allow-Methods": true,
            "method.response.header.Access-Control-Allow-Origin": true
          }' || echo "OPTIONS method response may already exist"
        
        # Set up OPTIONS integration for CORS
        echo "Setting up OPTIONS integration..."
        aws apigateway put-integration \
          --rest-api-id $API_ID \
          --resource-id $CHAT_RESOURCE_ID \
          --http-method OPTIONS \
          --type MOCK \
          --request-templates '{"application/json": "{\"statusCode\": 200}"}' || echo "OPTIONS integration may already exist"
        
        # Set up OPTIONS integration response for CORS
        echo "Setting up OPTIONS integration response..."
        aws apigateway put-integration-response \
          --rest-api-id $API_ID \
          --resource-id $CHAT_RESOURCE_ID \
          --http-method OPTIONS \
          --status-code 200 \
          --response-parameters '{
            "method.response.header.Access-Control-Allow-Headers": "'"'"'Content-Type,Authorization,X-Requested-With'"'"'",
            "method.response.header.Access-Control-Allow-Methods": "'"'"'POST,OPTIONS'"'"'",
            "method.response.header.Access-Control-Allow-Origin": "'"'"'*'"'"'"
          }' || echo "OPTIONS integration response may already exist"
        
        # Set up knowledge-base POST method
        echo "Setting up knowledge-base POST method..."
        aws apigateway put-method \
          --rest-api-id $API_ID \
          --resource-id $KNOWLEDGE_BASE_RESOURCE_ID \
          --http-method POST \
          --authorization-type NONE || echo "Knowledge-base POST method may already exist"
        
        # Set up knowledge-base OPTIONS method for CORS
        echo "Setting up knowledge-base OPTIONS method..."
        aws apigateway put-method \
          --rest-api-id $API_ID \
          --resource-id $KNOWLEDGE_BASE_RESOURCE_ID \
          --http-method OPTIONS \
          --authorization-type NONE || echo "Knowledge-base OPTIONS method may already exist"
        
        # Set up knowledge-base POST integration
        echo "Setting up knowledge-base POST integration..."
        aws apigateway put-integration \
          --rest-api-id $API_ID \
          --resource-id $KNOWLEDGE_BASE_RESOURCE_ID \
          --http-method POST \
          --type AWS_PROXY \
          --integration-http-method POST \
          --uri "arn:aws:apigateway:${{ env.AWS_REGION }}:lambda:path/2015-03-31/functions/arn:aws:lambda:${{ env.AWS_REGION }}:090163643302:function:chatbot-orchestrator/invocations" || echo "Knowledge-base POST integration may already exist"
        
        # Set up knowledge-base OPTIONS method response for CORS
        echo "Setting up knowledge-base OPTIONS method response..."
        aws apigateway put-method-response \
          --rest-api-id $API_ID \
          --resource-id $KNOWLEDGE_BASE_RESOURCE_ID \
          --http-method OPTIONS \
          --status-code 200 \
          --response-parameters '{
            "method.response.header.Access-Control-Allow-Headers": true,
            "method.response.header.Access-Control-Allow-Methods": true,
            "method.response.header.Access-Control-Allow-Origin": true
          }' || echo "Knowledge-base OPTIONS method response may already exist"
        
        # Set up knowledge-base OPTIONS integration for CORS
        echo "Setting up knowledge-base OPTIONS integration..."
        aws apigateway put-integration \
          --rest-api-id $API_ID \
          --resource-id $KNOWLEDGE_BASE_RESOURCE_ID \
          --http-method OPTIONS \
          --type MOCK \
          --request-templates '{"application/json": "{\"statusCode\": 200}"}' || echo "Knowledge-base OPTIONS integration may already exist"
        
        # Set up knowledge-base OPTIONS integration response for CORS
        echo "Setting up knowledge-base OPTIONS integration response..."
        aws apigateway put-integration-response \
          --rest-api-id $API_ID \
          --resource-id $KNOWLEDGE_BASE_RESOURCE_ID \
          --http-method OPTIONS \
          --status-code 200 \
          --response-parameters '{
            "method.response.header.Access-Control-Allow-Headers": "'"'"'Content-Type,Authorization,X-Requested-With'"'"'",
            "method.response.header.Access-Control-Allow-Methods": "'"'"'POST,OPTIONS'"'"'",
            "method.response.header.Access-Control-Allow-Origin": "'"'"'*'"'"'"
          }' || echo "Knowledge-base OPTIONS integration response may already exist"
        
        # Deploy API Gateway
        echo "Deploying API Gateway..."
        aws apigateway create-deployment \
          --rest-api-id $API_ID \
          --stage-name prod || echo "Deployment may already exist"
        
        # Add Lambda permission for API Gateway
        echo "Adding Lambda permission..."
        aws lambda add-permission \
          --function-name chatbot-orchestrator \
          --statement-id apigateway-invoke-$(date +%s) \
          --action lambda:InvokeFunction \
          --principal apigateway.amazonaws.com \
          --source-arn "arn:aws:execute-api:${{ env.AWS_REGION }}:090163643302:$API_ID/*/*" || echo "Permission may already exist"
        
        # Output API URL
        API_URL="https://$API_ID.execute-api.${{ env.AWS_REGION }}.amazonaws.com/prod"
        echo "API Gateway URL: $API_URL"
        echo "API_GATEWAY_URL=$API_URL" >> $GITHUB_ENV

  configure-s3-notifications:
    runs-on: ubuntu-latest
    environment: chatbot
    if: always()
    needs: []
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Configure S3 Bucket Notifications
      run: |
        echo "ðŸ”” Configuring S3 bucket notifications for document processing..."
        
        BUCKET_NAME="chatbot-storage-ap-south-1"
        RAG_PROCESSOR_LAMBDA="chatbot-rag-processor"
        
        # Check if bucket exists
        if ! aws s3api head-bucket --bucket $BUCKET_NAME --region ${{ env.AWS_REGION }} 2>/dev/null; then
          echo "âŒ Bucket $BUCKET_NAME does not exist. Creating it..."
          aws s3 mb s3://$BUCKET_NAME --region ${{ env.AWS_REGION }}
        fi
        
        # Check if RAG processor lambda exists
        if ! aws lambda get-function --function-name $RAG_PROCESSOR_LAMBDA --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
          echo "âŒ Lambda function $RAG_PROCESSOR_LAMBDA does not exist. Skipping S3 notification setup."
          exit 0
        fi
        
        # Get the Lambda function ARN
        LAMBDA_ARN=$(aws lambda get-function --function-name $RAG_PROCESSOR_LAMBDA --region ${{ env.AWS_REGION }} --query 'Configuration.FunctionArn' --output text)
        echo "ðŸ“‹ Lambda ARN: $LAMBDA_ARN"
        
        # Add permission for S3 to invoke the Lambda function
        echo "ðŸ” Adding S3 permission to invoke Lambda function..."
        aws lambda add-permission \
          --function-name $RAG_PROCESSOR_LAMBDA \
          --statement-id s3-invoke-$(date +%s) \
          --action lambda:InvokeFunction \
          --principal s3.amazonaws.com \
          --source-arn "arn:aws:s3:::$BUCKET_NAME" \
          --region ${{ env.AWS_REGION }} || echo "Permission may already exist"
        
        # Create S3 bucket notification configuration
        echo "ðŸ“ Creating S3 bucket notification configuration..."
        cat > s3-notification-config.json << EOF
        {
            "LambdaFunctionConfigurations": [
                {
                    "Id": "DocumentProcessingTrigger",
                    "LambdaFunctionArn": "$LAMBDA_ARN",
                    "Events": ["s3:ObjectCreated:Put"],
                    "Filter": {
                        "Key": {
                            "FilterRules": [
                                {
                                    "Name": "prefix",
                                    "Value": "documents/"
                                }
                            ]
                        }
                    }
                }
            ]
        }
        EOF
        
        # Apply the notification configuration
        echo "ðŸš€ Applying S3 bucket notification configuration..."
        aws s3api put-bucket-notification-configuration \
          --bucket $BUCKET_NAME \
          --notification-configuration file://s3-notification-config.json \
          --region ${{ env.AWS_REGION }}
        
        # Verify the configuration
        echo "âœ… Verifying S3 bucket notification configuration..."
        aws s3api get-bucket-notification-configuration --bucket $BUCKET_NAME --region ${{ env.AWS_REGION }}
        
        # Clean up
        rm -f s3-notification-config.json
        
        echo "ðŸŽ‰ S3 bucket notifications configured successfully!"

    - name: Configure S3 CORS Policy
      run: |
        echo "ðŸŒ Configuring S3 CORS policy for frontend access..."
        
        BUCKET_NAME="chatbot-storage-ap-south-1"
        
        # Create CORS configuration
        cat > s3-cors-config.json << EOF
        {
            "CORSRules": [
                {
                    "AllowedHeaders": ["*"],
                    "AllowedMethods": ["GET", "PUT", "POST", "DELETE", "HEAD"],
                    "AllowedOrigins": [
                        "http://localhost:3000",
                        "http://localhost:8080",
                        "http://127.0.0.1:3000",
                        "http://127.0.0.1:8080"
                    ],
                    "ExposeHeaders": [
                        "ETag",
                        "x-amz-meta-metadata",
                        "x-amz-meta-original-filename",
                        "x-amz-meta-upload-timestamp",
                        "x-amz-request-id",
                        "x-amz-version-id"
                    ],
                    "MaxAgeSeconds": 3000
                }
            ]
        }
        EOF
        
        # Apply CORS configuration
        aws s3api put-bucket-cors \
          --bucket $BUCKET_NAME \
          --cors-configuration file://s3-cors-config.json \
          --region ${{ env.AWS_REGION }}
        
        # Verify CORS configuration
        echo "âœ… Verifying S3 CORS configuration..."
        aws s3api get-bucket-cors --bucket $BUCKET_NAME --region ${{ env.AWS_REGION }}
        
        # Clean up
        rm -f s3-cors-config.json
        
        echo "ðŸŽ‰ S3 CORS policy configured successfully!"

    - name: Update Frontend Configuration
      run: |
        # Update the frontend configuration with the new API URL
        sed -i "s|https://your-microservices-api-gateway-url.execute-api.ap-south-1.amazonaws.com/dev|${{ env.API_GATEWAY_URL }}|g" src/lib/aws-config.ts

    - name: Commit updated configuration
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add src/lib/aws-config.ts
        git commit -m "Update API Gateway URL for microservices" || echo "No changes to commit"
        git push || echo "Nothing to push"
