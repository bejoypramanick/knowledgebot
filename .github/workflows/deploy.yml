name: Deploy Microservices

on:
  push:
    branches: [ main ]
    paths:
      - 'backend/lambda/**'
      - '.github/workflows/deploy.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'backend/lambda/**'
      - '.github/workflows/deploy.yml'
  workflow_dispatch:
    inputs:
      force_rebuild:
        description: 'Force rebuild all services'
        required: false
        default: 'false'
        type: boolean

env:
  AWS_REGION: ap-south-1
  ECR_REGISTRY: 090163643302.dkr.ecr.ap-south-1.amazonaws.com

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.changes.outputs.matrix }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Detect changed services
      id: changes
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.force_rebuild }}" = "true" ]; then
          echo "Force rebuild enabled - building all services"
          echo "matrix={\"include\":[{\"service\":\"rag-processor\"},{\"service\":\"chat-handler\"},{\"service\":\"orchestrator\"},{\"service\":\"rag-search\"},{\"service\":\"document-management\"},{\"service\":\"response-enhancement\"},{\"service\":\"claude-decision\"},{\"service\":\"action-executor\"},{\"service\":\"embedding-service\"},{\"service\":\"vector-search\"},{\"service\":\"document-metadata\"},{\"service\":\"document-content\"},{\"service\":\"source-extractor\"},{\"service\":\"response-formatter\"},{\"service\":\"conversation-manager\"}]}" >> $GITHUB_OUTPUT
        else
          # Check for changes in each service directory
          services_to_build=()
          
          # Define all services
          services=(
            "rag-processor"
            "chat-handler"
            "orchestrator"
            "rag-search"
            "document-management"
            "response-enhancement"
            "claude-decision"
            "action-executor"
            "embedding-service"
            "vector-search"
            "document-metadata"
            "document-content"
            "source-extractor"
            "response-formatter"
            "conversation-manager"
          )
          
          # Check each service for changes
          for service in "${services[@]}"; do
            if git diff --name-only HEAD~1 HEAD | grep -q "^backend/lambda/$service/"; then
              echo "Changes detected in $service"
              services_to_build+=("$service")
            fi
          done
          
          # Always build core services if no changes detected
          if [ ${#services_to_build[@]} -eq 0 ]; then
            echo "No specific changes detected - building all services"
            services_to_build=(
              "action-executor"
              "chat-handler" 
              "claude-decision"
              "conversation-manager"
              "document-content"
              "document-management"
              "document-metadata"
              "embedding-service"
              "orchestrator"
              "rag-processor"
              "rag-search"
              "response-enhancement"
              "response-formatter"
              "source-extractor"
              "vector-search"
            )
          fi
          
          # Create matrix JSON
          matrix_json="{\"include\":["
          for i in "${!services_to_build[@]}"; do
            if [ $i -gt 0 ]; then
              matrix_json+=","
            fi
            matrix_json+="{\"service\":\"${services_to_build[$i]}\"}"
          done
          matrix_json+="]}"
          
          echo "matrix=$matrix_json" >> $GITHUB_OUTPUT
          echo "Services to build: ${services_to_build[*]}"
        fi

  build-and-deploy:
    needs: detect-changes
    runs-on: ubuntu-latest
    environment: chatbot
    strategy:
      matrix: ${{ fromJson(needs.detect-changes.outputs.matrix) }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Create ECR repository
      run: |
        echo "Ensuring ECR repository exists for ${{ matrix.service }}..."
        if aws ecr describe-repositories --repository-names "chatbot-${{ matrix.service }}" --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
          echo "Repository chatbot-${{ matrix.service }} already exists"
        else
          echo "Creating repository chatbot-${{ matrix.service }}..."
          aws ecr create-repository --repository-name "chatbot-${{ matrix.service }}" --region ${{ env.AWS_REGION }}
        fi

    - name: Build and push Docker image
      run: |
        echo "Building and pushing ${{ matrix.service }}..."
        
        # Verify shared directory exists
        if [ -d "backend/lambda/shared" ]; then
          echo "Shared directory found at backend/lambda/shared"
        else
          echo "Warning: Shared directory not found, but continuing with build"
        fi
        
        # Build Docker image with correct context (lambda directory)
        echo "Starting Docker build for ${{ matrix.service }}..."
        echo "Build context: backend/lambda"
        echo "Dockerfile: backend/lambda/${{ matrix.service }}/Dockerfile"
        
        docker build -t chatbot-${{ matrix.service }} -f backend/lambda/${{ matrix.service }}/Dockerfile backend/lambda || {
          echo "Docker build failed for ${{ matrix.service }}"
          exit 1
        }
        
        # Tag for ECR
        echo "Tagging image for ECR..."
        docker tag chatbot-${{ matrix.service }}:latest ${{ env.ECR_REGISTRY }}/chatbot-${{ matrix.service }}:latest
        
        # Push to ECR
        echo "Pushing image to ECR..."
        docker push ${{ env.ECR_REGISTRY }}/chatbot-${{ matrix.service }}:latest || {
          echo "Docker push failed for ${{ matrix.service }}"
          exit 1
        }
        
        echo "Successfully completed ${{ matrix.service }}"

    - name: Deploy Lambda function
      run: |
        echo "Deploying Lambda function for ${{ matrix.service }}..."
        
        # Service configurations
        case "${{ matrix.service }}" in
          "rag-processor")
            memory=2048; timeout=300; env_vars="MAIN_BUCKET=chatbot-storage-ap-south-1,KNOWLEDGE_BASE_TABLE=chatbot-knowledge-base"
            ;;
          "chat-handler")
            memory=1024; timeout=300; env_vars="CLAUDE_API_KEY=${{ secrets.CLAUDE_API_KEY }},MAIN_BUCKET=chatbot-storage-ap-south-1,CONVERSATIONS_TABLE=chatbot-conversations,KNOWLEDGE_BASE_TABLE=chatbot-knowledge-base"
            ;;
          "orchestrator")
            memory=1024; timeout=300; env_vars="CLAUDE_API_KEY=${{ secrets.CLAUDE_API_KEY }},RAG_SEARCH_LAMBDA=chatbot-rag-search,DOCUMENT_MANAGEMENT_LAMBDA=chatbot-document-management,RESPONSE_ENHANCEMENT_LAMBDA=chatbot-response-enhancement,CONVERSATIONS_TABLE=chatbot-conversations"
            ;;
          "rag-search")
            memory=2048; timeout=300; env_vars="MAIN_BUCKET=chatbot-storage-ap-south-1,KNOWLEDGE_BASE_TABLE=chatbot-knowledge-base"
            ;;
          "document-management")
            memory=512; timeout=300; env_vars="MAIN_BUCKET=chatbot-storage-ap-south-1,KNOWLEDGE_BASE_TABLE=chatbot-knowledge-base"
            ;;
          "response-enhancement")
            memory=1024; timeout=300; env_vars="CLAUDE_API_KEY=${{ secrets.CLAUDE_API_KEY }},CONVERSATIONS_TABLE=chatbot-conversations"
            ;;
          "claude-decision")
            memory=1024; timeout=300; env_vars="CLAUDE_API_KEY=${{ secrets.CLAUDE_API_KEY }},CONVERSATIONS_TABLE=chatbot-conversations"
            ;;
          "action-executor")
            memory=512; timeout=300; env_vars="RAG_SEARCH_LAMBDA=chatbot-rag-search,DOCUMENT_METADATA_LAMBDA=chatbot-document-metadata,DOCUMENT_CONTENT_LAMBDA=chatbot-document-content,EMBEDDING_SERVICE_LAMBDA=chatbot-embedding-service,VECTOR_SEARCH_LAMBDA=chatbot-vector-search"
            ;;
          "embedding-service")
            memory=2048; timeout=300; env_vars="MAIN_BUCKET=chatbot-storage-ap-south-1"
            ;;
          "vector-search")
            memory=1024; timeout=300; env_vars="MAIN_BUCKET=chatbot-storage-ap-south-1,KNOWLEDGE_BASE_TABLE=chatbot-knowledge-base"
            ;;
          "document-metadata")
            memory=256; timeout=300; env_vars="MAIN_BUCKET=chatbot-storage-ap-south-1,KNOWLEDGE_BASE_TABLE=chatbot-knowledge-base"
            ;;
          "document-content")
            memory=256; timeout=300; env_vars="MAIN_BUCKET=chatbot-storage-ap-south-1"
            ;;
          "source-extractor")
            memory=256; timeout=300; env_vars=""
            ;;
          "response-formatter")
            memory=256; timeout=300; env_vars=""
            ;;
          "conversation-manager")
            memory=256; timeout=300; env_vars="CONVERSATIONS_TABLE=chatbot-conversations"
            ;;
        esac
        
        # Create or update Lambda function
        if aws lambda get-function --function-name "chatbot-${{ matrix.service }}" --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
          echo "Lambda function chatbot-${{ matrix.service }} already exists, updating code..."
          aws lambda update-function-code \
            --function-name "chatbot-${{ matrix.service }}" \
            --image-uri "${{ env.ECR_REGISTRY }}/chatbot-${{ matrix.service }}:latest" || {
              echo "Failed to update Lambda function ${{ matrix.service }}"
              exit 1
            }
          echo "Successfully updated Lambda function ${{ matrix.service }}"
        else
          echo "Creating Lambda function chatbot-${{ matrix.service }}..."
          aws lambda create-function \
            --function-name "chatbot-${{ matrix.service }}" \
            --package-type Image \
            --code ImageUri="${{ env.ECR_REGISTRY }}/chatbot-${{ matrix.service }}:latest" \
            --role "arn:aws:iam::090163643302:role/chatbot-microservices-lambda-role" \
            --timeout $timeout \
            --memory-size $memory \
            --environment Variables="{$env_vars}" \
            --tags Environment=production,Service=${{ matrix.service }} || {
              echo "Failed to create Lambda function ${{ matrix.service }}"
              exit 1
            }
          echo "Successfully created Lambda function ${{ matrix.service }}"
        fi

  create-api-gateway:
    needs: [detect-changes, build-and-deploy]
    runs-on: ubuntu-latest
    environment: chatbot
    if: always()
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Create or update API Gateway
      run: |
        echo "Setting up API Gateway..."
        
        # Check if API Gateway exists
        API_ID=$(aws apigateway get-rest-apis --query 'items[?name==`chatbot-microservices-api`].id' --output text)
        
        if [ -z "$API_ID" ] || [ "$API_ID" = "None" ]; then
          echo "Creating new API Gateway..."
          API_ID=$(aws apigateway create-rest-api \
            --name chatbot-microservices-api \
            --description "API Gateway for chatbot microservices" \
            --query 'id' --output text)
        else
          echo "Using existing API Gateway: $API_ID"
        fi
        
        echo "API_ID=$API_ID" >> $GITHUB_ENV
        
        # Get root resource ID
        ROOT_RESOURCE_ID=$(aws apigateway get-resources --rest-api-id $API_ID --query 'items[?path==`/`].id' --output text)
        
        # Create chat resource
        CHAT_RESOURCE_ID=$(aws apigateway create-resource \
          --rest-api-id $API_ID \
          --parent-id $ROOT_RESOURCE_ID \
          --path-part chat \
          --query 'id' --output text)
        
        # Create POST method
        aws apigateway put-method \
          --rest-api-id $API_ID \
          --resource-id $CHAT_RESOURCE_ID \
          --http-method POST \
          --authorization-type NONE
        
        # Create OPTIONS method for CORS
        aws apigateway put-method \
          --rest-api-id $API_ID \
          --resource-id $CHAT_RESOURCE_ID \
          --http-method OPTIONS \
          --authorization-type NONE
        
        # Set up POST integration
        aws apigateway put-integration \
          --rest-api-id $API_ID \
          --resource-id $CHAT_RESOURCE_ID \
          --http-method POST \
          --type AWS_PROXY \
          --integration-http-method POST \
          --uri "arn:aws:apigateway:${{ env.AWS_REGION }}:lambda:path/2015-03-31/functions/arn:aws:lambda:${{ env.AWS_REGION }}:090163643302:function:chatbot-orchestrator/invocations"
        
        # Set up OPTIONS integration for CORS
        aws apigateway put-integration \
          --rest-api-id $API_ID \
          --resource-id $CHAT_RESOURCE_ID \
          --http-method OPTIONS \
          --type MOCK \
          --request-templates '{"application/json": "{\"statusCode\": 200}"}'
        
        # Deploy API Gateway
        aws apigateway create-deployment \
          --rest-api-id $API_ID \
          --stage-name prod
        
        # Add Lambda permission for API Gateway
        aws lambda add-permission \
          --function-name chatbot-orchestrator \
          --statement-id apigateway-invoke \
          --action lambda:InvokeFunction \
          --principal apigateway.amazonaws.com \
          --source-arn "arn:aws:execute-api:${{ env.AWS_REGION }}:090163643302:$API_ID/*/*" || echo "Permission already exists"
        
        # Output API URL
        API_URL="https://$API_ID.execute-api.${{ env.AWS_REGION }}.amazonaws.com/prod"
        echo "API Gateway URL: $API_URL"
        echo "API_GATEWAY_URL=$API_URL" >> $GITHUB_ENV

    - name: Update Frontend Configuration
      run: |
        # Update the frontend configuration with the new API URL
        sed -i "s|https://your-microservices-api-gateway-url.execute-api.ap-south-1.amazonaws.com/dev|${{ env.API_GATEWAY_URL }}|g" src/lib/aws-config.ts

    - name: Commit updated configuration
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add src/lib/aws-config.ts
        git commit -m "Update API Gateway URL for microservices" || echo "No changes to commit"
        git push || echo "Nothing to push"
