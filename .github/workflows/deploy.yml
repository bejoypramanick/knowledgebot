name: Deploy Microservices

on:
  push:
    branches: [ main ]
    paths:
      - 'backend/lambda/**'
      - 'backend/base-images/**'
      - '.github/workflows/deploy.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'backend/lambda/**'
      - 'backend/base-images/**'
      - '.github/workflows/deploy.yml'
  workflow_dispatch:

env:
  AWS_REGION: ap-south-1
  ECR_REGISTRY: 090163643302.dkr.ecr.ap-south-1.amazonaws.com

jobs:
  detect-base-image-changes:
    runs-on: ubuntu-latest
    outputs:
      build-docling: ${{ steps.changes.outputs.build_docling }}
      build-sentence-transformers: ${{ steps.changes.outputs.build_sentence_transformers }}
      build-any: ${{ steps.changes.outputs.build_any }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Detect base image changes
      id: changes
      run: |
        # Get list of changed files
        if [ "${{ github.event_name }}" = "push" ]; then
          CHANGED_FILES=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }})
        else
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
        fi
        
        echo "Changed files:"
        echo "$CHANGED_FILES"
        
        # Check for changes in base image files
        BUILD_DOCLING="false"
        BUILD_SENTENCE_TRANSFORMERS="false"
        BUILD_ANY="false"
        
        if echo "$CHANGED_FILES" | grep -q "backend/base-images/Dockerfile.docling"; then
          BUILD_DOCLING="true"
          BUILD_ANY="true"
          echo "âœ… Docling base image needs rebuild"
        else
          echo "â­ï¸ Docling base image - no changes"
        fi
        
        if echo "$CHANGED_FILES" | grep -q "backend/base-images/Dockerfile.sentence-transformers"; then
          BUILD_SENTENCE_TRANSFORMERS="true"
          BUILD_ANY="true"
          echo "âœ… Sentence-transformers base image needs rebuild"
        else
          echo "â­ï¸ Sentence-transformers base image - no changes"
        fi
        
        # If any base image files changed, set build_any to true
        if echo "$CHANGED_FILES" | grep -q "backend/base-images/"; then
          BUILD_ANY="true"
        fi
        
        echo "build_docling=$BUILD_DOCLING" >> $GITHUB_OUTPUT
        echo "build_sentence_transformers=$BUILD_SENTENCE_TRANSFORMERS" >> $GITHUB_OUTPUT
        echo "build_any=$BUILD_ANY" >> $GITHUB_OUTPUT

  build-base-images:
    needs: detect-base-image-changes
    if: needs.detect-base-image-changes.outputs.build_any == 'true'
    runs-on: ubuntu-latest
    environment: chatbot
    timeout-minutes: 30
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build and push base images
      run: |
        echo "ðŸ—ï¸ Building and pushing base images..."
        
        # Create ECR repositories for base images
        for base_image in docling sentence-transformers; do
          echo "ðŸ“‹ Ensuring ECR repository exists for chatbot-base-$base_image..."
          if aws ecr describe-repositories --repository-names "chatbot-base-$base_image" --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
            echo "Repository chatbot-base-$base_image already exists"
          else
            echo "Creating repository chatbot-base-$base_image..."
            aws ecr create-repository --repository-name "chatbot-base-$base_image" --region ${{ env.AWS_REGION }}
            
            # Set ECR repository policy
            aws ecr set-repository-policy \
              --repository-name "chatbot-base-$base_image" \
              --region ${{ env.AWS_REGION }} \
              --policy-text '{
                  "Version": "2012-10-17",
                  "Statement": [
                      {
                          "Sid": "LambdaECRImageRetrievalPolicy",
                          "Effect": "Allow",
                          "Principal": {
                              "Service": "lambda.amazonaws.com"
                          },
                          "Action": [
                              "ecr:BatchGetImage",
                              "ecr:GetDownloadUrlForLayer"
                          ]
                      }
                  ]
              }' || echo "Policy already set"
          fi
        done
        
        # Build and push base images
        cd backend/base-images
        
        # Build only the images that have changes
        if [ "${{ needs.detect-base-image-changes.outputs.build_docling }}" = "true" ]; then
          echo "ðŸ”¨ Building docling base image..."
          docker build -f Dockerfile.docling -t chatbot-base-docling:latest .
          docker tag chatbot-base-docling:latest ${{ env.ECR_REGISTRY }}/chatbot-base-docling:latest
          docker push ${{ env.ECR_REGISTRY }}/chatbot-base-docling:latest
          docker rmi chatbot-base-docling:latest ${{ env.ECR_REGISTRY }}/chatbot-base-docling:latest || true
          echo "âœ… Docling base image built and pushed successfully!"
        fi
        
        if [ "${{ needs.detect-base-image-changes.outputs.build_sentence_transformers }}" = "true" ]; then
          echo "ðŸ”¨ Building sentence-transformers base image..."
          docker build -f Dockerfile.sentence-transformers -t chatbot-base-sentence-transformers:latest .
          docker tag chatbot-base-sentence-transformers:latest ${{ env.ECR_REGISTRY }}/chatbot-base-sentence-transformers:latest
          docker push ${{ env.ECR_REGISTRY }}/chatbot-base-sentence-transformers:latest
          docker rmi chatbot-base-sentence-transformers:latest ${{ env.ECR_REGISTRY }}/chatbot-base-sentence-transformers:latest || true
          echo "âœ… Sentence-transformers base image built and pushed successfully!"
        fi
        
        echo "ðŸŽ‰ Base images build completed!"

  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      services: ${{ steps.changes.outputs.services }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Detect changed services
      id: changes
      run: |
        # Get list of changed files
        if [ "${{ github.event_name }}" = "push" ]; then
          CHANGED_FILES=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }})
        else
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
        fi
        
        echo "Changed files:"
        echo "$CHANGED_FILES"
        
        # Check for changes in each service
        CHANGED_SERVICES=""
        
        for service in action-executor chat-handler claude-decision conversation-manager document-content document-management document-metadata embedding-service orchestrator presigned-url rag-processor rag-search response-enhancement response-formatter source-extractor vector-search; do
          if echo "$CHANGED_FILES" | grep -q "backend/lambda/$service/"; then
            CHANGED_SERVICES="$CHANGED_SERVICES $service"
            echo "âœ… $service has changes"
          else
            echo "â­ï¸ $service - no changes"
          fi
        done
        
        # If no specific services changed, but lambda files changed, build all
        if [ -z "$CHANGED_SERVICES" ] && echo "$CHANGED_FILES" | grep -q "backend/lambda/"; then
          echo "ðŸ”„ No specific service changes detected, building all services"
          CHANGED_SERVICES="action-executor chat-handler claude-decision conversation-manager document-content document-management document-metadata embedding-service orchestrator rag-processor rag-search response-enhancement response-formatter source-extractor vector-search"
        fi
        
        # If no lambda changes at all, don't build anything
        if [ -z "$CHANGED_SERVICES" ]; then
          echo "â­ï¸ No lambda changes detected, skipping build"
          echo "services=[]" >> $GITHUB_OUTPUT
        else
          echo "ðŸ“¦ Services to build: $CHANGED_SERVICES"
          # Convert to JSON array - more robust approach
          SERVICES_ARRAY=()
          for service in $CHANGED_SERVICES; do
            if [ -n "$service" ]; then
              SERVICES_ARRAY+=("\"$service\"")
            fi
          done
          SERVICES_JSON="[$(IFS=,; echo "${SERVICES_ARRAY[*]}")]"
          echo "services=$SERVICES_JSON" >> $GITHUB_OUTPUT
        fi

  build-and-deploy:
    needs: [detect-base-image-changes, build-base-images, detect-changes]
    if: needs.detect-changes.outputs.services != '[]'
    runs-on: ubuntu-latest
    environment: chatbot
    timeout-minutes: 45
    strategy:
      max-parallel: 5
      matrix:
        service: ${{ fromJson(needs.detect-changes.outputs.services) }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Create ECR repository
      run: |
        echo "Ensuring ECR repository exists for ${{ matrix.service }}..."
        if aws ecr describe-repositories --repository-names "chatbot-${{ matrix.service }}" --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
          echo "Repository chatbot-${{ matrix.service }} already exists"
        else
          echo "Creating repository chatbot-${{ matrix.service }}..."
          aws ecr create-repository --repository-name "chatbot-${{ matrix.service }}" --region ${{ env.AWS_REGION }}
        fi
        
        # Set ECR repository policy to allow Lambda access
        echo "Setting ECR repository policy for Lambda access..."
        aws ecr set-repository-policy \
          --repository-name "chatbot-${{ matrix.service }}" \
          --region ${{ env.AWS_REGION }} \
          --policy-text '{
            "Version": "2012-10-17",
            "Statement": [
              {
                "Sid": "LambdaECRImageRetrievalPolicy",
                "Effect": "Allow",
                "Principal": {
                  "Service": "lambda.amazonaws.com"
                },
                "Action": [
                  "ecr:BatchGetImage",
                  "ecr:GetDownloadUrlForLayer"
                ]
              }
            ]
          }' || echo "Policy already set or failed to set"

    - name: Build and push Docker image
      run: |
        echo "Building and pushing ${{ matrix.service }}..."
        
        # Verify shared directory exists
        if [ -d "backend/lambda/shared" ]; then
          echo "Shared directory found at backend/lambda/shared"
        else
          echo "Warning: Shared directory not found, but continuing with build"
        fi
        
        # Build Docker image with correct context (lambda directory)
        echo "Starting Docker build for ${{ matrix.service }}..."
        echo "Build context: backend/lambda"
        echo "Dockerfile: backend/lambda/${{ matrix.service }}/Dockerfile"
        
        # Build with optimizations to reduce resource usage
        docker build --no-cache --memory=2g --memory-swap=2g -t chatbot-${{ matrix.service }} -f backend/lambda/${{ matrix.service }}/Dockerfile backend/lambda || {
          echo "Docker build failed for ${{ matrix.service }}"
          exit 1
        }
        
        # Tag for ECR
        echo "Tagging image for ECR..."
        docker tag chatbot-${{ matrix.service }}:latest ${{ env.ECR_REGISTRY }}/chatbot-${{ matrix.service }}:latest
        
        # Push to ECR with retry logic
        echo "Pushing image to ECR..."
        for i in {1..3}; do
          echo "Push attempt $i/3 for ${{ matrix.service }}..."
          if docker push ${{ env.ECR_REGISTRY }}/chatbot-${{ matrix.service }}:latest; then
            echo "Successfully pushed ${{ matrix.service }} on attempt $i"
            break
          else
            echo "Push attempt $i failed for ${{ matrix.service }}"
            if [ $i -eq 3 ]; then
              echo "All push attempts failed for ${{ matrix.service }}"
              exit 1
            fi
            echo "Waiting 10 seconds before retry..."
            sleep 10
          fi
        done
        
        # Clean up local image to save space
        echo "Cleaning up local image for ${{ matrix.service }}..."
        docker rmi chatbot-${{ matrix.service }}:latest ${{ env.ECR_REGISTRY }}/chatbot-${{ matrix.service }}:latest || true
        
        # Clean up Docker system resources
        echo "Cleaning up Docker system resources..."
        docker system prune -f || true
        
        echo "Successfully completed ${{ matrix.service }}"

    - name: Ensure IAM role exists
      run: |
        echo "Ensuring IAM role exists..."
        aws iam get-role --role-name chatbot-lambda-role || {
          echo "Creating IAM role chatbot-lambda-role..."
          aws iam create-role \
            --role-name chatbot-lambda-role \
            --assume-role-policy-document '{
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Principal": {
                    "Service": "lambda.amazonaws.com"
                  },
                  "Action": "sts:AssumeRole"
                }
              ]
            }'
          
          aws iam attach-role-policy \
            --role-name chatbot-lambda-role \
            --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
          
          aws iam attach-role-policy \
            --role-name chatbot-lambda-role \
            --policy-arn arn:aws:iam::aws:policy/AmazonS3FullAccess
          
          aws iam attach-role-policy \
            --role-name chatbot-lambda-role \
            --policy-arn arn:aws:iam::aws:policy/AmazonDynamoDBFullAccess
          
          # Add ECR permissions
          aws iam attach-role-policy \
            --role-name chatbot-lambda-role \
            --policy-arn arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly
          
          echo "IAM role created successfully"
        }

    - name: Deploy Lambda function
      run: |
        echo "Deploying Lambda function for ${{ matrix.service }}..."
        
        # Service configurations
        case "${{ matrix.service }}" in
          "rag-processor")
            memory=2048; timeout=900; env_vars="MAIN_BUCKET=chatbot-storage-ap-south-1,KNOWLEDGE_BASE_TABLE=chatbot-knowledge-base"
            ;;
          "chat-handler")
            memory=1024; timeout=300; env_vars="CLAUDE_API_KEY=${{ secrets.CLAUDE_API_KEY }},MAIN_BUCKET=chatbot-storage-ap-south-1,CONVERSATIONS_TABLE=chatbot-conversations,KNOWLEDGE_BASE_TABLE=chatbot-knowledge-base"
            ;;
          "orchestrator")
            memory=1024; timeout=300; env_vars="CLAUDE_API_KEY=${{ secrets.CLAUDE_API_KEY }},RAG_SEARCH_LAMBDA=chatbot-rag-search,DOCUMENT_MANAGEMENT_LAMBDA=chatbot-document-management,RESPONSE_ENHANCEMENT_LAMBDA=chatbot-response-enhancement,CONVERSATIONS_TABLE=chatbot-conversations"
            ;;
          "rag-search")
            memory=2048; timeout=300; env_vars="MAIN_BUCKET=chatbot-storage-ap-south-1,KNOWLEDGE_BASE_TABLE=chatbot-knowledge-base"
            ;;
          "document-management")
            memory=512; timeout=300; env_vars="MAIN_BUCKET=chatbot-storage-ap-south-1,KNOWLEDGE_BASE_TABLE=chatbot-knowledge-base"
            ;;
          "response-enhancement")
            memory=1024; timeout=300; env_vars="CLAUDE_API_KEY=${{ secrets.CLAUDE_API_KEY }},CONVERSATIONS_TABLE=chatbot-conversations"
            ;;
          "claude-decision")
            memory=1024; timeout=300; env_vars="CLAUDE_API_KEY=${{ secrets.CLAUDE_API_KEY }},CONVERSATIONS_TABLE=chatbot-conversations"
            ;;
          "action-executor")
            memory=512; timeout=300; env_vars="RAG_SEARCH_LAMBDA=chatbot-rag-search,DOCUMENT_METADATA_LAMBDA=chatbot-document-metadata,DOCUMENT_CONTENT_LAMBDA=chatbot-document-content,EMBEDDING_SERVICE_LAMBDA=chatbot-embedding-service,VECTOR_SEARCH_LAMBDA=chatbot-vector-search"
            ;;
          "embedding-service")
            memory=2048; timeout=300; env_vars="MAIN_BUCKET=chatbot-storage-ap-south-1"
            ;;
          "vector-search")
            memory=1024; timeout=300; env_vars="MAIN_BUCKET=chatbot-storage-ap-south-1,KNOWLEDGE_BASE_TABLE=chatbot-knowledge-base"
            ;;
          "document-metadata")
            memory=256; timeout=300; env_vars="MAIN_BUCKET=chatbot-storage-ap-south-1,KNOWLEDGE_BASE_TABLE=chatbot-knowledge-base"
            ;;
          "document-content")
            memory=256; timeout=300; env_vars="MAIN_BUCKET=chatbot-storage-ap-south-1"
            ;;
          "source-extractor")
            memory=256; timeout=300; env_vars=""
            ;;
          "response-formatter")
            memory=256; timeout=300; env_vars=""
            ;;
          "conversation-manager")
            memory=256; timeout=300; env_vars="CONVERSATIONS_TABLE=chatbot-conversations"
            ;;
          "presigned-url")
            memory=512; timeout=300; env_vars="MAIN_BUCKET=chatbot-storage-ap-south-1"
            ;;
        esac
        
        # Create or update Lambda function
        if aws lambda get-function --function-name "chatbot-${{ matrix.service }}" --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
          echo "Lambda function chatbot-${{ matrix.service }} already exists, updating code..."
          aws lambda update-function-code \
            --function-name "chatbot-${{ matrix.service }}" \
            --image-uri "${{ env.ECR_REGISTRY }}/chatbot-${{ matrix.service }}:latest" || {
              echo "Failed to update Lambda function ${{ matrix.service }}"
              exit 1
            }
          echo "Successfully updated Lambda function ${{ matrix.service }}"
        else
          echo "Creating Lambda function chatbot-${{ matrix.service }}..."
          aws lambda create-function \
            --function-name "chatbot-${{ matrix.service }}" \
            --package-type Image \
            --code ImageUri="${{ env.ECR_REGISTRY }}/chatbot-${{ matrix.service }}:latest" \
            --role "arn:aws:iam::090163643302:role/chatbot-lambda-role" \
            --timeout $timeout \
            --memory-size $memory \
            --environment Variables="{$env_vars}" \
            --tags Environment=production,Service=${{ matrix.service }} || {
              echo "Failed to create Lambda function ${{ matrix.service }}"
              exit 1
            }
          echo "Successfully created Lambda function ${{ matrix.service }}"
        fi

  create-api-gateway:
    needs: [detect-changes]
    runs-on: ubuntu-latest
    environment: chatbot
    if: always()
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Create or update API Gateway
      run: |
        echo "Setting up API Gateway..."
        
        # Check if API Gateway exists
        API_ID=$(aws apigateway get-rest-apis --query 'items[?name==`chatbot-microservices-api`].id' --output text)
        
        if [ -z "$API_ID" ] || [ "$API_ID" = "None" ]; then
          echo "Creating new API Gateway..."
          API_ID=$(aws apigateway create-rest-api \
            --name chatbot-microservices-api \
            --description "API Gateway for chatbot microservices" \
            --query 'id' --output text)
        else
          echo "Using existing API Gateway: $API_ID"
        fi
        
        echo "API_ID=$API_ID" >> $GITHUB_ENV
        
        # Get root resource ID
        ROOT_RESOURCE_ID=$(aws apigateway get-resources --rest-api-id $API_ID --query 'items[?path==`/`].id' --output text)
        
        # Create or get chat resource
        echo "Creating or getting chat resource..."
        CHAT_RESOURCE_ID=$(aws apigateway get-resources \
          --rest-api-id $API_ID \
          --query "items[?pathPart=='chat' && parentId=='$ROOT_RESOURCE_ID'].id" --output text)
        
        if [ -z "$CHAT_RESOURCE_ID" ] || [ "$CHAT_RESOURCE_ID" = "None" ]; then
          echo "Creating new chat resource..."
          CHAT_RESOURCE_ID=$(aws apigateway create-resource \
            --rest-api-id $API_ID \
            --parent-id $ROOT_RESOURCE_ID \
            --path-part chat \
            --query 'id' --output text)
        else
          echo "Using existing chat resource: $CHAT_RESOURCE_ID"
        fi
        
        # Create or get knowledge-base resource
        echo "Creating or getting knowledge-base resource..."
        KNOWLEDGE_BASE_RESOURCE_ID=$(aws apigateway get-resources \
          --rest-api-id $API_ID \
          --query "items[?pathPart=='knowledge-base' && parentId=='$ROOT_RESOURCE_ID'].id" --output text)
        
        if [ -z "$KNOWLEDGE_BASE_RESOURCE_ID" ] || [ "$KNOWLEDGE_BASE_RESOURCE_ID" = "None" ]; then
          echo "Creating new knowledge-base resource..."
          KNOWLEDGE_BASE_RESOURCE_ID=$(aws apigateway create-resource \
            --rest-api-id $API_ID \
            --parent-id $ROOT_RESOURCE_ID \
            --path-part knowledge-base \
            --query 'id' --output text)
        else
          echo "Using existing knowledge-base resource: $KNOWLEDGE_BASE_RESOURCE_ID"
        fi
        
        # Create or update POST method
        echo "Setting up POST method..."
        aws apigateway put-method \
          --rest-api-id $API_ID \
          --resource-id $CHAT_RESOURCE_ID \
          --http-method POST \
          --authorization-type NONE || echo "POST method may already exist"
        
        # Create or update OPTIONS method for CORS
        echo "Setting up OPTIONS method..."
        aws apigateway put-method \
          --rest-api-id $API_ID \
          --resource-id $CHAT_RESOURCE_ID \
          --http-method OPTIONS \
          --authorization-type NONE || echo "OPTIONS method may already exist"
        
        # Set up POST integration
        echo "Setting up POST integration..."
        aws apigateway put-integration \
          --rest-api-id $API_ID \
          --resource-id $CHAT_RESOURCE_ID \
          --http-method POST \
          --type AWS_PROXY \
          --integration-http-method POST \
          --uri "arn:aws:apigateway:${{ env.AWS_REGION }}:lambda:path/2015-03-31/functions/arn:aws:lambda:${{ env.AWS_REGION }}:090163643302:function:chatbot-orchestrator/invocations" || echo "POST integration may already exist"
        
        # Set up OPTIONS method response for CORS (must be before integration response)
        echo "Setting up OPTIONS method response..."
        aws apigateway put-method-response \
          --rest-api-id $API_ID \
          --resource-id $CHAT_RESOURCE_ID \
          --http-method OPTIONS \
          --status-code 200 \
          --response-parameters '{
            "method.response.header.Access-Control-Allow-Headers": true,
            "method.response.header.Access-Control-Allow-Methods": true,
            "method.response.header.Access-Control-Allow-Origin": true
          }' || echo "OPTIONS method response may already exist"
        
        # Set up OPTIONS integration for CORS
        echo "Setting up OPTIONS integration..."
        aws apigateway put-integration \
          --rest-api-id $API_ID \
          --resource-id $CHAT_RESOURCE_ID \
          --http-method OPTIONS \
          --type MOCK \
          --request-templates '{"application/json": "{\"statusCode\": 200}"}' || echo "OPTIONS integration may already exist"
        
        # Set up OPTIONS integration response for CORS
        echo "Setting up OPTIONS integration response..."
        aws apigateway put-integration-response \
          --rest-api-id $API_ID \
          --resource-id $CHAT_RESOURCE_ID \
          --http-method OPTIONS \
          --status-code 200 \
          --response-parameters '{
            "method.response.header.Access-Control-Allow-Headers": "'"'"'Content-Type,Authorization,X-Requested-With'"'"'",
            "method.response.header.Access-Control-Allow-Methods": "'"'"'POST,OPTIONS'"'"'",
            "method.response.header.Access-Control-Allow-Origin": "'"'"'*'"'"'"
          }' || echo "OPTIONS integration response may already exist"
        
        # Set up knowledge-base POST method
        echo "Setting up knowledge-base POST method..."
        aws apigateway put-method \
          --rest-api-id $API_ID \
          --resource-id $KNOWLEDGE_BASE_RESOURCE_ID \
          --http-method POST \
          --authorization-type NONE || echo "Knowledge-base POST method may already exist"
        
        # Set up knowledge-base OPTIONS method for CORS
        echo "Setting up knowledge-base OPTIONS method..."
        aws apigateway put-method \
          --rest-api-id $API_ID \
          --resource-id $KNOWLEDGE_BASE_RESOURCE_ID \
          --http-method OPTIONS \
          --authorization-type NONE || echo "Knowledge-base OPTIONS method may already exist"
        
        # Set up knowledge-base POST integration
        echo "Setting up knowledge-base POST integration..."
        aws apigateway put-integration \
          --rest-api-id $API_ID \
          --resource-id $KNOWLEDGE_BASE_RESOURCE_ID \
          --http-method POST \
          --type AWS_PROXY \
          --integration-http-method POST \
          --uri "arn:aws:apigateway:${{ env.AWS_REGION }}:lambda:path/2015-03-31/functions/arn:aws:lambda:${{ env.AWS_REGION }}:090163643302:function:chatbot-orchestrator/invocations" || echo "Knowledge-base POST integration may already exist"
        
        # Set up knowledge-base OPTIONS method response for CORS
        echo "Setting up knowledge-base OPTIONS method response..."
        aws apigateway put-method-response \
          --rest-api-id $API_ID \
          --resource-id $KNOWLEDGE_BASE_RESOURCE_ID \
          --http-method OPTIONS \
          --status-code 200 \
          --response-parameters '{
            "method.response.header.Access-Control-Allow-Headers": true,
            "method.response.header.Access-Control-Allow-Methods": true,
            "method.response.header.Access-Control-Allow-Origin": true
          }' || echo "Knowledge-base OPTIONS method response may already exist"
        
        # Set up knowledge-base OPTIONS integration for CORS
        echo "Setting up knowledge-base OPTIONS integration..."
        aws apigateway put-integration \
          --rest-api-id $API_ID \
          --resource-id $KNOWLEDGE_BASE_RESOURCE_ID \
          --http-method OPTIONS \
          --type MOCK \
          --request-templates '{"application/json": "{\"statusCode\": 200}"}' || echo "Knowledge-base OPTIONS integration may already exist"
        
        # Set up knowledge-base OPTIONS integration response for CORS
        echo "Setting up knowledge-base OPTIONS integration response..."
        aws apigateway put-integration-response \
          --rest-api-id $API_ID \
          --resource-id $KNOWLEDGE_BASE_RESOURCE_ID \
          --http-method OPTIONS \
          --status-code 200 \
          --response-parameters '{
            "method.response.header.Access-Control-Allow-Headers": "'"'"'Content-Type,Authorization,X-Requested-With'"'"'",
            "method.response.header.Access-Control-Allow-Methods": "'"'"'POST,OPTIONS'"'"'",
            "method.response.header.Access-Control-Allow-Origin": "'"'"'*'"'"'"
          }' || echo "Knowledge-base OPTIONS integration response may already exist"
        
        # Deploy API Gateway
        echo "Deploying API Gateway..."
        aws apigateway create-deployment \
          --rest-api-id $API_ID \
          --stage-name prod || echo "Deployment may already exist"
        
        # Add Lambda permission for API Gateway
        echo "Adding Lambda permission..."
        aws lambda add-permission \
          --function-name chatbot-orchestrator \
          --statement-id apigateway-invoke-$(date +%s) \
          --action lambda:InvokeFunction \
          --principal apigateway.amazonaws.com \
          --source-arn "arn:aws:execute-api:${{ env.AWS_REGION }}:090163643302:$API_ID/*/*" || echo "Permission may already exist"
        
        # Output API URL
        API_URL="https://$API_ID.execute-api.${{ env.AWS_REGION }}.amazonaws.com/prod"
        echo "API Gateway URL: $API_URL"
        echo "API_GATEWAY_URL=$API_URL" >> $GITHUB_ENV

  configure-s3-notifications:
    runs-on: ubuntu-latest
    environment: chatbot
    if: always()
    needs: []
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Configure S3 Bucket Notifications
      run: |
        echo "ðŸ”” Configuring S3 bucket notifications for document processing..."
        
        BUCKET_NAME="chatbot-storage-ap-south-1"
        RAG_PROCESSOR_LAMBDA="chatbot-rag-processor"
        
        # Check if bucket exists
        if ! aws s3api head-bucket --bucket $BUCKET_NAME --region ${{ env.AWS_REGION }} 2>/dev/null; then
          echo "âŒ Bucket $BUCKET_NAME does not exist. Creating it..."
          aws s3 mb s3://$BUCKET_NAME --region ${{ env.AWS_REGION }}
        fi
        
        # Check if RAG processor lambda exists
        if ! aws lambda get-function --function-name $RAG_PROCESSOR_LAMBDA --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
          echo "âŒ Lambda function $RAG_PROCESSOR_LAMBDA does not exist. Skipping S3 notification setup."
          exit 0
        fi
        
        # Get the Lambda function ARN
        LAMBDA_ARN=$(aws lambda get-function --function-name $RAG_PROCESSOR_LAMBDA --region ${{ env.AWS_REGION }} --query 'Configuration.FunctionArn' --output text)
        echo "ðŸ“‹ Lambda ARN: $LAMBDA_ARN"
        
        # Add permission for S3 to invoke the Lambda function
        echo "ðŸ” Adding S3 permission to invoke Lambda function..."
        aws lambda add-permission \
          --function-name $RAG_PROCESSOR_LAMBDA \
          --statement-id s3-invoke-$(date +%s) \
          --action lambda:InvokeFunction \
          --principal s3.amazonaws.com \
          --source-arn "arn:aws:s3:::$BUCKET_NAME" \
          --region ${{ env.AWS_REGION }} || echo "Permission may already exist"
        
        # Create S3 bucket notification configuration
        echo "ðŸ“ Creating S3 bucket notification configuration..."
        cat > s3-notification-config.json << EOF
        {
            "LambdaFunctionConfigurations": [
                {
                    "Id": "DocumentProcessingTrigger",
                    "LambdaFunctionArn": "$LAMBDA_ARN",
                    "Events": ["s3:ObjectCreated:Put"],
                    "Filter": {
                        "Key": {
                            "FilterRules": [
                                {
                                    "Name": "prefix",
                                    "Value": "documents/"
                                }
                            ]
                        }
                    }
                }
            ]
        }
        EOF
        
        # Apply the notification configuration
        echo "ðŸš€ Applying S3 bucket notification configuration..."
        aws s3api put-bucket-notification-configuration \
          --bucket $BUCKET_NAME \
          --notification-configuration file://s3-notification-config.json \
          --region ${{ env.AWS_REGION }}
        
        # Verify the configuration
        echo "âœ… Verifying S3 bucket notification configuration..."
        aws s3api get-bucket-notification-configuration --bucket $BUCKET_NAME --region ${{ env.AWS_REGION }}
        
        # Clean up
        rm -f s3-notification-config.json
        
        echo "ðŸŽ‰ S3 bucket notifications configured successfully!"

    - name: Configure S3 CORS Policy
      run: |
        echo "ðŸŒ Configuring S3 CORS policy for frontend access..."
        
        BUCKET_NAME="chatbot-storage-ap-south-1"
        
        # Create CORS configuration
        cat > s3-cors-config.json << EOF
        {
            "CORSRules": [
                {
                    "AllowedHeaders": ["*"],
                    "AllowedMethods": ["GET", "PUT", "POST", "DELETE", "HEAD"],
                    "AllowedOrigins": [
                        "http://localhost:3000",
                        "http://localhost:8080",
                        "http://127.0.0.1:3000",
                        "http://127.0.0.1:8080"
                    ],
                    "ExposeHeaders": [
                        "ETag",
                        "x-amz-meta-metadata",
                        "x-amz-meta-original-filename",
                        "x-amz-meta-upload-timestamp",
                        "x-amz-request-id",
                        "x-amz-version-id"
                    ],
                    "MaxAgeSeconds": 3000
                }
            ]
        }
        EOF
        
        # Apply CORS configuration
        aws s3api put-bucket-cors \
          --bucket $BUCKET_NAME \
          --cors-configuration file://s3-cors-config.json \
          --region ${{ env.AWS_REGION }}
        
        # Verify CORS configuration
        echo "âœ… Verifying S3 CORS configuration..."
        aws s3api get-bucket-cors --bucket $BUCKET_NAME --region ${{ env.AWS_REGION }}
        
        # Clean up
        rm -f s3-cors-config.json
        
        echo "ðŸŽ‰ S3 CORS policy configured successfully!"

    - name: Update Frontend Configuration
      run: |
        # Update the frontend configuration with the new API URL
        sed -i "s|https://your-microservices-api-gateway-url.execute-api.ap-south-1.amazonaws.com/dev|${{ env.API_GATEWAY_URL }}|g" src/lib/aws-config.ts

    - name: Commit updated configuration
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add src/lib/aws-config.ts
        git commit -m "Update API Gateway URL for microservices" || echo "No changes to commit"
        git push || echo "Nothing to push"
# Workflow test
