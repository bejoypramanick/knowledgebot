name: Deploy Lambda Containers

on:
  push:
    branches: [ main ]
    paths:
      - 'backend/lambda/**'
      - '.github/workflows/deploy-lambda-containers.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'backend/lambda/**'
      - '.github/workflows/deploy-lambda-containers.yml'
  workflow_dispatch:
    inputs:
      force_cleanup:
        description: 'Force cleanup of all ECR images (except latest and cache)'
        required: false
        default: 'false'
        type: boolean

env:
  AWS_REGION: ap-south-1
  ECR_REGISTRY: 090163643302.dkr.ecr.ap-south-1.amazonaws.com
  RAG_PROCESSOR_IMAGE: chatbot-rag-processor
  CHAT_HANDLER_IMAGE: chatbot-chat-handler

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    environment: chatbot
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Debug environment secrets
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        CLAUDE_API_KEY: ${{ secrets.CLAUDE_API_KEY }}
      run: |
        echo "Environment: ${{ github.environment }}"
        echo "Branch: ${{ github.ref_name }}"
        echo "Event: ${{ github.event_name }}"
        echo ""
        echo "Checking if secrets are available..."
        if [ -n "$AWS_ACCESS_KEY_ID" ]; then
          echo "âœ… AWS_ACCESS_KEY_ID is available"
        else
          echo "âŒ AWS_ACCESS_KEY_ID is not available"
        fi
        if [ -n "$AWS_SECRET_ACCESS_KEY" ]; then
          echo "âœ… AWS_SECRET_ACCESS_KEY is available"
        else
          echo "âŒ AWS_SECRET_ACCESS_KEY is not available"
        fi
        if [ -n "$CLAUDE_API_KEY" ]; then
          echo "âœ… CLAUDE_API_KEY is available"
        else
          echo "âŒ CLAUDE_API_KEY is not available"
        fi

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Free up disk space
      run: |
        echo "Freeing up disk space before Docker build..."
        # Remove large directories that aren't needed
        sudo rm -rf /usr/share/dotnet
        sudo rm -rf /usr/local/lib/android
        sudo rm -rf /opt/ghc
        sudo rm -rf /usr/local/share/boost
        sudo rm -rf /opt/hostedtoolcache
        # Clean up package cache
        sudo apt-get purge -y '^dotnet-.*' 'php.*' 'llvm-.*' 'libllvm.*' 'mono-.*' 'monodoc-.*'
        sudo apt-get autoremove -y
        sudo apt-get clean
        # Show available space
        df -h

    - name: Check for RAG Processor changes
      id: rag-changes
      run: |
        # Check if any files in rag-processor directory changed
        if git diff --name-only HEAD~1 HEAD | grep -E '^backend/lambda/rag-processor/'; then
          echo "rag-changed=true" >> $GITHUB_OUTPUT
          echo "RAG Processor changes detected - will rebuild"
        else
          echo "rag-changed=false" >> $GITHUB_OUTPUT
          echo "No RAG Processor changes - will reuse existing image"
        fi

    - name: Clean up old ECR images
      run: |
        echo "ðŸ§¹ Cleaning up old ECR images..."
        
        # Determine cleanup strategy based on input
        if [ "${{ github.event.inputs.force_cleanup }}" = "true" ]; then
          echo "ðŸ”¥ Force cleanup enabled - deleting ALL images except latest and cache"
          KEEP_COUNT=0
        else
          echo "ðŸ“¦ Standard cleanup - keeping last 5 versions"
          KEEP_COUNT=5
        fi
        
        # Clean up RAG Processor images
        echo "Cleaning RAG Processor images..."
        if [ $KEEP_COUNT -eq 0 ]; then
          # Delete all except latest and cache
          aws ecr describe-images --repository-name $RAG_PROCESSOR_IMAGE --region $AWS_REGION --query 'imageDetails[?imageTags!=`null` && !contains(imageTags, `latest`) && !contains(imageTags, `cache`)] | [].imageDigest' --output text > rag_old_images.txt || echo "" > rag_old_images.txt
        else
          # Keep last N versions
          aws ecr describe-images --repository-name $RAG_PROCESSOR_IMAGE --region $AWS_REGION --query 'imageDetails[?imageTags!=`null`] | sort_by(@, &imagePushedAt) | reverse(@) | ['$KEEP_COUNT':] | [].imageDigest' --output text > rag_old_images.txt || echo "" > rag_old_images.txt
        fi
        
        if [ -s rag_old_images.txt ]; then
          echo "Deleting old RAG Processor images..."
          aws ecr batch-delete-image --repository-name $RAG_PROCESSOR_IMAGE --region $AWS_REGION --image-ids imageDigest=$(cat rag_old_images.txt | tr '\n' ' ') || echo "No old RAG images to delete"
        else
          echo "No old RAG Processor images to delete"
        fi
        
        # Clean up Chat Handler images
        echo "Cleaning Chat Handler images..."
        if [ $KEEP_COUNT -eq 0 ]; then
          # Delete all except latest and cache
          aws ecr describe-images --repository-name $CHAT_HANDLER_IMAGE --region $AWS_REGION --query 'imageDetails[?imageTags!=`null` && !contains(imageTags, `latest`) && !contains(imageTags, `cache`)] | [].imageDigest' --output text > chat_old_images.txt || echo "" > chat_old_images.txt
        else
          # Keep last N versions
          aws ecr describe-images --repository-name $CHAT_HANDLER_IMAGE --region $AWS_REGION --query 'imageDetails[?imageTags!=`null`] | sort_by(@, &imagePushedAt) | reverse(@) | ['$KEEP_COUNT':] | [].imageDigest' --output text > chat_old_images.txt || echo "" > chat_old_images.txt
        fi
        
        if [ -s chat_old_images.txt ]; then
          echo "Deleting old Chat Handler images..."
          aws ecr batch-delete-image --repository-name $CHAT_HANDLER_IMAGE --region $AWS_REGION --image-ids imageDigest=$(cat chat_old_images.txt | tr '\n' ' ') || echo "No old Chat images to delete"
        else
          echo "No old Chat Handler images to delete"
        fi
        
        # Clean up temporary files
        rm -f rag_old_images.txt chat_old_images.txt
        
        echo "âœ… ECR cleanup completed"

    - name: Build and push RAG Processor image
      if: steps.rag-changes.outputs.rag-changed == 'true'
      env:
        ECR_REPOSITORY: ${{ env.RAG_PROCESSOR_IMAGE }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        echo "ðŸš€ Starting RAG Processor build at $(date)"
        start_time=$(date +%s)
        # Create ECR repository if it doesn't exist
        aws ecr describe-repositories --repository-names $ECR_REPOSITORY --region $AWS_REGION || \
        aws ecr create-repository --repository-name $ECR_REPOSITORY --region $AWS_REGION
        
        # Pull existing images for cache (multiple tags for better cache hit rate)
        echo "Pulling existing images for cache..."
        docker pull $ECR_REGISTRY/$ECR_REPOSITORY:latest || true
        docker pull $ECR_REGISTRY/$ECR_REPOSITORY:cache || true
        
        # Build image with aggressive ECR layer caching
        echo "Building with ECR layer caching..."
        docker buildx build \
          --platform linux/amd64 \
          --cache-from type=registry,ref=$ECR_REGISTRY/$ECR_REPOSITORY:latest \
          --cache-from type=registry,ref=$ECR_REGISTRY/$ECR_REPOSITORY:cache \
          --cache-from type=gha,scope=rag-processor \
          --cache-to type=registry,ref=$ECR_REGISTRY/$ECR_REPOSITORY:cache,mode=max \
          --cache-to type=gha,scope=rag-processor,mode=max \
          --tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
          --tag $ECR_REGISTRY/$ECR_REPOSITORY:latest \
          --load \
          --progress=plain \
          ./backend/lambda/rag-processor
        
        # Push images to ECR with strict error handling
        echo "ðŸš€ Pushing RAG Processor image to ECR..."
        if ! docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG; then
          echo "âŒ CRITICAL ERROR: Failed to push RAG Processor image with tag $IMAGE_TAG"
          echo "This indicates ECR permissions or connectivity issues"
          exit 1
        fi
        
        if ! docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest; then
          echo "âŒ CRITICAL ERROR: Failed to push RAG Processor latest image"
          echo "This indicates ECR permissions or connectivity issues"
          exit 1
        fi
        
        # Push cache layers to ECR for future builds (non-critical)
        echo "ðŸ“¦ Pushing cache layers..."
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:cache || echo "âš ï¸ Cache push failed (non-critical)"
        
        # Show build timing
        end_time=$(date +%s)
        duration=$((end_time - start_time))
        echo "âœ… RAG Processor build completed in ${duration} seconds"

    - name: Use existing RAG Processor image
      if: steps.rag-changes.outputs.rag-changed == 'false'
      env:
        ECR_REPOSITORY: ${{ env.RAG_PROCESSOR_IMAGE }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Try to pull existing latest image and retag it, or build if it doesn't exist
        if docker pull $ECR_REGISTRY/$ECR_REPOSITORY:latest 2>/dev/null; then
          echo "âœ… Found existing image, retagging..."
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:latest $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          if ! docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG; then
            echo "âŒ CRITICAL ERROR: Failed to push retagged RAG Processor image"
            echo "This indicates ECR permissions or connectivity issues"
            exit 1
          fi
        else
          echo "âŒ No existing image found, building new one..."
          # Build the image
          cd backend/lambda/rag-processor
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          if ! docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG; then
            echo "âŒ CRITICAL ERROR: Failed to push newly built RAG Processor image"
            echo "This indicates ECR permissions or connectivity issues"
            exit 1
          fi
          # Also tag as latest for future use
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          if ! docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest; then
            echo "âŒ CRITICAL ERROR: Failed to push RAG Processor latest image"
            echo "This indicates ECR permissions or connectivity issues"
            exit 1
          fi
        fi

    - name: Check for Chat Handler changes
      id: chat-changes
      run: |
        # Check if any files in chat-handler directory changed
        if git diff --name-only HEAD~1 HEAD | grep -E '^backend/lambda/chat-handler/'; then
          echo "chat-changed=true" >> $GITHUB_OUTPUT
          echo "Chat Handler changes detected - will rebuild"
        else
          echo "chat-changed=false" >> $GITHUB_OUTPUT
          echo "No Chat Handler changes - will reuse existing image"
        fi

    - name: Build and push Chat Handler image
      if: steps.chat-changes.outputs.chat-changed == 'true'
      env:
        ECR_REPOSITORY: ${{ env.CHAT_HANDLER_IMAGE }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        echo "ðŸš€ Starting Chat Handler build at $(date)"
        start_time=$(date +%s)
        # Create ECR repository if it doesn't exist
        aws ecr describe-repositories --repository-names $ECR_REPOSITORY --region $AWS_REGION || \
        aws ecr create-repository --repository-name $ECR_REPOSITORY --region $AWS_REGION
        
        # Pull existing images for cache (multiple tags for better cache hit rate)
        echo "Pulling existing images for cache..."
        docker pull $ECR_REGISTRY/$ECR_REPOSITORY:latest || true
        docker pull $ECR_REGISTRY/$ECR_REPOSITORY:cache || true
        
        # Build image with aggressive ECR layer caching
        echo "Building with ECR layer caching..."
        docker buildx build \
          --platform linux/amd64 \
          --cache-from type=registry,ref=$ECR_REGISTRY/$ECR_REPOSITORY:latest \
          --cache-from type=registry,ref=$ECR_REGISTRY/$ECR_REPOSITORY:cache \
          --cache-from type=gha,scope=chat-handler \
          --cache-to type=registry,ref=$ECR_REGISTRY/$ECR_REPOSITORY:cache,mode=max \
          --cache-to type=gha,scope=chat-handler,mode=max \
          --tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
          --tag $ECR_REGISTRY/$ECR_REPOSITORY:latest \
          --load \
          --progress=plain \
          ./backend/lambda/chat-handler
        
        # Push images to ECR with strict error handling
        echo "ðŸš€ Pushing Chat Handler image to ECR..."
        if ! docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG; then
          echo "âŒ CRITICAL ERROR: Failed to push Chat Handler image with tag $IMAGE_TAG"
          echo "This indicates ECR permissions or connectivity issues"
          exit 1
        fi
        
        if ! docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest; then
          echo "âŒ CRITICAL ERROR: Failed to push Chat Handler latest image"
          echo "This indicates ECR permissions or connectivity issues"
          exit 1
        fi
        
        # Push cache layers to ECR for future builds (non-critical)
        echo "ðŸ“¦ Pushing cache layers..."
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:cache || echo "âš ï¸ Cache push failed (non-critical)"
        
        # Show build timing
        end_time=$(date +%s)
        duration=$((end_time - start_time))
        echo "âœ… Chat Handler build completed in ${duration} seconds"

    - name: Use existing Chat Handler image
      if: steps.chat-changes.outputs.chat-changed == 'false'
      env:
        ECR_REPOSITORY: ${{ env.CHAT_HANDLER_IMAGE }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Try to pull existing latest image and retag it, or build if it doesn't exist
        if docker pull $ECR_REGISTRY/$ECR_REPOSITORY:latest 2>/dev/null; then
          echo "âœ… Found existing image, retagging..."
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:latest $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          if ! docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG; then
            echo "âŒ CRITICAL ERROR: Failed to push retagged Chat Handler image"
            echo "This indicates ECR permissions or connectivity issues"
            exit 1
          fi
        else
          echo "âŒ No existing image found, building new one..."
          # Build the image
          cd backend/lambda/chat-handler
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          if ! docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG; then
            echo "âŒ CRITICAL ERROR: Failed to push newly built Chat Handler image"
            echo "This indicates ECR permissions or connectivity issues"
            exit 1
          fi
          # Also tag as latest for future use
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          if ! docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest; then
            echo "âŒ CRITICAL ERROR: Failed to push Chat Handler latest image"
            echo "This indicates ECR permissions or connectivity issues"
            exit 1
          fi
        fi

    - name: Verify ECR Images Uploaded
      run: |
        echo "ðŸ” Verifying that images were successfully uploaded to ECR..."
        
        # Verify RAG Processor image
        echo "Checking RAG Processor image..."
        if ! aws ecr describe-images --repository-name $RAG_PROCESSOR_IMAGE --region $AWS_REGION --image-ids imageTag=${{ github.sha }} > /dev/null 2>&1; then
          echo "âŒ CRITICAL ERROR: RAG Processor image with tag ${{ github.sha }} not found in ECR"
          echo "This indicates the image push failed silently"
          exit 1
        fi
        
        if ! aws ecr describe-images --repository-name $RAG_PROCESSOR_IMAGE --region $AWS_REGION --image-ids imageTag=latest > /dev/null 2>&1; then
          echo "âŒ CRITICAL ERROR: RAG Processor latest image not found in ECR"
          echo "This indicates the latest tag push failed silently"
          exit 1
        fi
        
        echo "âœ… RAG Processor images verified in ECR"
        
        # Verify Chat Handler image
        echo "Checking Chat Handler image..."
        if ! aws ecr describe-images --repository-name $CHAT_HANDLER_IMAGE --region $AWS_REGION --image-ids imageTag=${{ github.sha }} > /dev/null 2>&1; then
          echo "âŒ CRITICAL ERROR: Chat Handler image with tag ${{ github.sha }} not found in ECR"
          echo "This indicates the image push failed silently"
          exit 1
        fi
        
        if ! aws ecr describe-images --repository-name $CHAT_HANDLER_IMAGE --region $AWS_REGION --image-ids imageTag=latest > /dev/null 2>&1; then
          echo "âŒ CRITICAL ERROR: Chat Handler latest image not found in ECR"
          echo "This indicates the latest tag push failed silently"
          exit 1
        fi
        
        echo "âœ… Chat Handler images verified in ECR"
        
        # Show image details for confirmation
        echo "ðŸ“‹ Image Details:"
        echo "RAG Processor:"
        aws ecr describe-images --repository-name $RAG_PROCESSOR_IMAGE --region $AWS_REGION --query 'imageDetails[?contains(imageTags, `'${{ github.sha }}'`) || contains(imageTags, `latest`)].{Tags:imageTags,PushedAt:imagePushedAt}' --output table
        
        echo "Chat Handler:"
        aws ecr describe-images --repository-name $CHAT_HANDLER_IMAGE --region $AWS_REGION --query 'imageDetails[?contains(imageTags, `'${{ github.sha }}'`) || contains(imageTags, `latest`)].{Tags:imageTags,PushedAt:imagePushedAt}' --output table
        
        echo "ðŸŽ‰ All images successfully verified in ECR!"

    - name: Deploy RAG Processor Lambda
      env:
        ECR_REPOSITORY: ${{ env.RAG_PROCESSOR_IMAGE }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Check if Lambda function exists
        if aws lambda get-function --function-name $ECR_REPOSITORY --region $AWS_REGION > /dev/null 2>&1; then
          # Update existing function
          aws lambda update-function-code \
            --function-name $ECR_REPOSITORY \
            --image-uri $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            --region $AWS_REGION
        else
          # Create new function
          aws lambda create-function \
            --function-name $ECR_REPOSITORY \
            --package-type Image \
            --code ImageUri=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            --role arn:aws:iam::090163643302:role/chatbot-lambda-role \
            --timeout 900 \
            --memory-size 2048 \
            --region $AWS_REGION
        fi

    - name: Deploy Chat Handler Lambda
      env:
        ECR_REPOSITORY: ${{ env.CHAT_HANDLER_IMAGE }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Check if Lambda function exists
        if aws lambda get-function --function-name $ECR_REPOSITORY --region $AWS_REGION > /dev/null 2>&1; then
          # Update existing function
          aws lambda update-function-code \
            --function-name $ECR_REPOSITORY \
            --image-uri $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            --region $AWS_REGION
        else
          # Create new function
          aws lambda create-function \
            --function-name $ECR_REPOSITORY \
            --package-type Image \
            --code ImageUri=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            --role arn:aws:iam::090163643302:role/chatbot-lambda-role \
            --timeout 300 \
            --memory-size 1024 \
            --region $AWS_REGION
        fi

    - name: Verify Lambda Functions Updated
      run: |
        echo "ðŸ” Verifying that Lambda functions are using the correct images..."
        
        # Verify RAG Processor Lambda
        echo "Checking RAG Processor Lambda function..."
        RAG_IMAGE_URI=$(aws lambda get-function --function-name $RAG_PROCESSOR_IMAGE --region $AWS_REGION --query 'Code.ImageUri' --output text)
        echo "RAG Processor using image: $RAG_IMAGE_URI"
        
        if [[ ! "$RAG_IMAGE_URI" == *"${{ github.sha }}"* ]]; then
          echo "âŒ CRITICAL ERROR: RAG Processor Lambda is not using the correct image"
          echo "Expected to contain: ${{ github.sha }}"
          echo "Actual image URI: $RAG_IMAGE_URI"
          exit 1
        fi
        
        # Verify Chat Handler Lambda
        echo "Checking Chat Handler Lambda function..."
        CHAT_IMAGE_URI=$(aws lambda get-function --function-name $CHAT_HANDLER_IMAGE --region $AWS_REGION --query 'Code.ImageUri' --output text)
        echo "Chat Handler using image: $CHAT_IMAGE_URI"
        
        if [[ ! "$CHAT_IMAGE_URI" == *"${{ github.sha }}"* ]]; then
          echo "âŒ CRITICAL ERROR: Chat Handler Lambda is not using the correct image"
          echo "Expected to contain: ${{ github.sha }}"
          echo "Actual image URI: $CHAT_IMAGE_URI"
          exit 1
        fi
        
        echo "âœ… Both Lambda functions are using the correct images"
        echo "ðŸŽ‰ Deployment verification completed successfully!"

    - name: Configure S3 Event Trigger
      run: |
        # Get the RAG processor Lambda function ARN
        RAG_ARN=$(aws lambda get-function --function-name $RAG_PROCESSOR_IMAGE --region $AWS_REGION --query 'Configuration.FunctionArn' --output text)
        
        # Add permission for S3 to invoke Lambda (remove existing first)
        aws lambda remove-permission \
          --function-name $RAG_PROCESSOR_IMAGE \
          --statement-id s3-trigger-permission \
          --region $AWS_REGION 2>/dev/null || echo "Permission doesn't exist yet"
        
        aws lambda add-permission \
          --function-name $RAG_PROCESSOR_IMAGE \
          --statement-id s3-trigger-permission \
          --action lambda:InvokeFunction \
          --principal s3.amazonaws.com \
          --source-arn arn:aws:s3:::chatbot-documents-ap-south-1 \
          --region $AWS_REGION
        
        # Create S3 event notification configuration
        aws s3api put-bucket-notification-configuration \
          --bucket chatbot-documents-ap-south-1 \
          --notification-configuration '{
            "LambdaFunctionConfigurations": [
              {
                "Id": "rag-processor-trigger",
                "LambdaFunctionArn": "'$RAG_ARN'",
                "Events": ["s3:ObjectCreated:Put"],
                "Filter": {
                  "Key": {
                    "FilterRules": [
                      {
                        "Name": "prefix",
                        "Value": "documents/"
                      }
                    ]
                  }
                }
              }
            ]
          }' \
          --region $AWS_REGION

    - name: Set Lambda Environment Variables
      run: |
        # Create environment variables JSON for RAG Processor
        cat > rag_env.json << EOF
        {
          "FunctionName": "$RAG_PROCESSOR_IMAGE",
          "Environment": {
            "Variables": {
              "DOCUMENTS_BUCKET": "chatbot-documents-ap-south-1",
              "EMBEDDINGS_BUCKET": "chatbot-embeddings-ap-south-1",
              "KNOWLEDGE_BASE_TABLE": "chatbot-knowledge-base",
              "CLAUDE_API_KEY": "${{ secrets.CLAUDE_API_KEY }}"
            }
          }
        }
        EOF
        
        # Create environment variables JSON for Chat Handler
        cat > chat_env.json << EOF
        {
          "FunctionName": "$CHAT_HANDLER_IMAGE",
          "Environment": {
            "Variables": {
              "DOCUMENTS_BUCKET": "chatbot-documents-ap-south-1",
              "KNOWLEDGE_BASE_TABLE": "chatbot-knowledge-base",
              "CONVERSATIONS_TABLE": "chatbot-conversations",
              "CLAUDE_API_KEY": "${{ secrets.CLAUDE_API_KEY }}",
              "RAG_PROCESSOR_LAMBDA": "chatbot-rag-processor"
            }
          }
        }
        EOF
        
        # Wait for any pending Lambda updates to complete
        echo "Waiting for any pending Lambda updates to complete..."
        aws lambda wait function-updated --function-name $RAG_PROCESSOR_IMAGE --region $AWS_REGION || echo "RAG Processor ready"
        aws lambda wait function-updated --function-name $CHAT_HANDLER_IMAGE --region $AWS_REGION || echo "Chat Handler ready"
        
        # Set environment variables for RAG Processor (with retry)
        for i in {1..3}; do
          if aws lambda update-function-configuration \
            --cli-input-json file://rag_env.json \
            --region $AWS_REGION; then
            echo "RAG Processor environment variables set successfully"
            break
          else
            echo "Attempt $i failed, waiting 10 seconds before retry..."
            sleep 10
          fi
        done
        
        # Set environment variables for Chat Handler (with retry)
        for i in {1..3}; do
          if aws lambda update-function-configuration \
            --cli-input-json file://chat_env.json \
            --region $AWS_REGION; then
            echo "Chat Handler environment variables set successfully"
            break
          else
            echo "Attempt $i failed, waiting 10 seconds before retry..."
            sleep 10
          fi
        done
        
        # Clean up temporary files
        rm -f rag_env.json chat_env.json

    - name: Output deployment information
      run: |
        echo "âœ… Deployment completed successfully!"
        echo "RAG Processor Lambda: $ECR_REGISTRY/$RAG_PROCESSOR_IMAGE:${{ github.sha }}"
        echo "Chat Handler Lambda: $ECR_REGISTRY/$CHAT_HANDLER_IMAGE:${{ github.sha }}"
        echo ""
        echo "Next steps:"
        echo "1. Update API Gateway integration to use the new Chat Handler Lambda"
        echo "2. Test document upload and chat functionality"
        echo "3. Monitor CloudWatch logs for any issues"
